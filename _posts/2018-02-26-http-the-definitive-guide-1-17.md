---
layout: post
title:  "[HTTP: The Definitive Guide] 17. 내용 협상과 트랜스코딩"
date:   2018-02-26 15:04:22 +0900
background: '/img/posts/05.jpg'
categories: http
---

## 내용 협상 기법
---
서버에 있는 페이지들 중 어떤 것이 클라이언트에 맞는지 자동으로 판단하는 세 가지 방법이 있다.
`클라이언트 주도 협상`, `서버 주도 협상` 그리고 `투명한 협상`이라고 불린다.

## 클라이언트 주도 협상
---
서버에게 가장 쉬운 방법은 서버가 클라이언트의 요청을 받았을 때 **가능한 페이지의 목록**을
응답으로 돌려주고, 클라이언트가 **선택**하게 하는 것이다.

이 방법은 서버 입장에서 가장 구현하기 쉽고, 클라이언트 입장에서는 최선의 선택이 된다.

단점은 각 페이지에 두 번의 `요청`이 필요하다는 것이다.
한 번은 목록을 얻고, 두 번째는 선택한 사본을 얻는다.

기술적으로 서버에게는 선택지를 표현하는 두 가지 방법이 있다.

첫 번째는 여러 버전에 대한 **링크**와 각각에 대한 **설명**이 담긴 `HTML 페이지`를 돌려주는 것이다.
이 결과로 클라이언트 브라우저는 링크와 함께 `페이지`를 보여주거나, 사용자의 결정을 돕는 `대화창`을 띄울 것이다.

두 번째는 `500 Multiple Choices` 응답 코드로 HTTP/1.1 응답을 돌려주는 것이다.

`클라이언트 주도 협상`에는 또 하나의 단점이 존재한다. 주 페이지 이외의 다른 `URL`을 요구한다는 점이다.
> 사용자는 링크를 담은 페이지를 북마크해야 하는지, 아니면 주 페이지를 북마크해야 하는지 선택하기 어렵다.

## 서버 주도 협상
---
`서버 주도 협상`은 클라이언트의 요청 헤더에서 정보를 얻어 최적의 페이지를 결정하는 방법이다.
메커니즘은 크게 두 가지 이다.
- 내용 협상 헤더인 `Accept` 관련 헤더들을 보고 이에 알맞은 응답 헤더를 준비한다.

- 내용 협상 외의 헤더들를 살펴본다. 예로 서버는 클라이언트의 `User-Agent` 헤더에 기반하여
응답을 보내줄 수도 있다.

#### 내용 협상 헤더
클라이언트는 다음의 HTTP 헤더들을 이용해서 자신의 선호 정보를 보낼 수 있다.
- `Accept` 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.
- `Accept-Language` 서버가 어떤 언어로 보내도 되는지 알려준다.
- `Accept-Charset` 서버가 어떤 캐릭터셋으로 보내도 되는지 알려준다.
- `Accept-Encoding` 서버가 어떤 인코딩으로 보내도 되는지 알려준다.

위 헤더들은 메시지 본문의 속성을 나타내는 `엔터티 헤더`와 비슷하지만, 클라이언트의 선호에 맞는
문서를 제공해주기 위한 목적으로 사용된다.

HTTP는 클라이언트가 이전 요청에 보낸 선호 정보를 서버가 기억하지 않는 `무상태(stateless)` 프로토콜이다.
따라서 클라이언트는 매 요청마다 자신의 선호 정보를 보내야만 한다.

서버가 응답으로 보낼 문서를 고르도록 하는 것은 클라이언트와 서버 간의 커뮤니케이션 대기시간을 줄여준다.

그러나 선택이 어려운 경우에는 서버의 `추측`이 들어가야 한다.
다행히도 HTTP는 여러 선택지에서 `품질값(quality value)`을 통해 적절한 선택을 할 수 있도록 도와준다.

#### 내용 협상 헤더의 품질값
HTTP 프로토콜은 클라이언트가 각 선호의 카테고리마다 `선호도`와 함께 나열할 수 있도록
품질값을 정의했다. q값은 `0.0-1.0`의 값을 가질 수 있다.

형식은 다음과 같으며, 서로 다른 버전을 `베리언트(variant)`라고 부른다. 
~~~
    Accept-Language: en;q=0.5, fr;q0.0, tr;q=0.0
~~~

서버는 클라이언트의 선호에 대응하는 문서를 가지고 있지 않을 수도 있다.
이러한 경우에는 클라이언트의 선호를 맞추기 위해 문서를 고치거나 `트랜스코딩`할 수 있다.

#### 그 외의 헤더들에 의해 결정
서버는 `User-Agent`와 같은 클라이언트의 다른 요청 헤더들을 이용해 적합한 요청을 만들어내려고
시도할 수 있다.

예로 브라우저가 자바스크립트를 지원하지 않는다는 것을 알고 있다면,
서버는 자바스크립트를 포함하지 않은 페이지를 돌려줄 수 있다.

이 사례에서 q값 메커니즘은 없다. 따라서 최적의 선택은 서버 구현에 달려있다.

캐시는 반드시 캐시된 문서의 `최선의 버전`을 제공해주려 하기에, HTTP 프로토콜은 서버가
응답에 넣어 보낼 수 있는 `Vary` 헤더를 정의한다.

Vary 헤더는 최선의 선택을 위해 서버가 어떤 요청 헤더를 **참고**하고 있는지 
캐시나 모든 다운스트림 프록시에게 말해준다.

#### 서버 측 확장
서버에서 내용 협상을 구현하는 또 다른 방법으로 `ASP`와 같이 서버 쪽에서 확장하는 방법이 있다.

## 투명 협상
---
투명 협상은 클라이언트 입장에서 협상 중개자 프록시를 둠으로써 클라이언트의 메시지 교환을 최소화하고,
서버 주도 협상으로 인한 부하를 제거하는 방법이다.

프록시는 클라이언트의 요구사항을 알고 있고, 협상을 수행할 수 있는 능력이 있는 것으로 가정한다.
HTTP/1.1 명세는 투명 협상에 대한 어떤 메커니즘도 정의하지 않았지만, 대신 `Vary` 헤더를 정의했다.

서버는 응답에 `Vary` 헤더를 보냄으로써 중개자에게 내용 협상에 어떤 헤더를 사용하고 있는지 알려줄 수 있다.

캐시 프록시는 `단일 URL`을 통해 접근할 수 있는 문서의 여러 사본을 저장할 수 있다.
만약 서버가 이들 캐시에 대한 **의사결정 프로세스**를 캐시에 알려주었다면,
캐시는 서버의 입장에서 협상을 진행할 수 있다.

또한, 캐시는 트랜스코딩하기 적합한 곳이다. 캐시 안에 설치되어 있는 `범용 트랜스코더`는
특정 서버에 국한되지 않고 어떤 컨텐츠든 트랜스코딩할 수 있기 때문이다.

#### 캐시와 얼터네이트(alternate)
컨텐츠를 캐시하는 이유는 추후 재사용될 것이라고 예상하기 때문이다.
캐시는 클라이언트로 올바른 캐시된 응답을 돌려주기 위해, 서버가 응답을 돌려줄 때 사용했던
**의사결정 로직**의 상당 부분을 그대로 사용한다.

따라서 캐시가 캐시된 응답을 돌려보낼 때에는 
서버 주도 협상에서 사용되었던 `Accept` 관련 헤더들을 사용해야 한다.

결국, 내용 협상은 베리언트 중에서 
클라이언트의 요청에 가장 잘 맞는 것을 선택하는 과정으로 이해할 수 있다.
> `베리언트(variant)`는 `얼터네이트(alternate)`라고도 불린다.

#### Vary 헤더
HTTP Vary 응답 헤더는 서버가 문서를 선택하거나 커스텀 컨텐츠를 생성할 때 고려한
클라이언트 요청 헤더 **모두**를 나열한다.

새 요청이 도착했을 때, 캐시는 내용 협상 헤더들을 참고하여 최적의 선택을 한다.
그러나 캐시가 문서를 제공해줄 수 있게 되기 전에는 반드시 캐시된 응답 안에 서버가 보낸
`Vary` 헤더가 있는지 확인해야 한다.

만약 존재한다면, Vary 헤더가 명시하고 있는 **헤더들의 값**은 이전 요청과 새 요청 모두 **동일**해야 한다.

왜냐하면 서버는 클라이언트의 요청 헤더에 따라 응답이 달라질 수 있고, 투명 협상을 구현하기 위해
캐시는 반드시 `캐시된 베리언트`와 `클라이언트 요청 헤더`, `서버 응답 헤더`를 저장해야 하기 때문이다.

캐시가 검색을 할 때, 먼저 내용 협상 헤더로 적합한 컨텐츠를 찾아본다. 다음에 요청 베리언트를 캐시된
베리언트와 맞춰본다. 만약 맞는 것이 없다면 캐시는 문서를 서버에서 가져온다.

## 트랜스코딩
---
내용 협상 메커니즘은 클라이언트의 요구에 맞는 문서가 존재해야 동작한다.

만약 이에 충족되는 문서가 아예 존재하지 않다면, 서버는 기존의 문서를 클라이언트가
사용할 수 있는 무언가로 변환할 수도 있다. 이 옵션을 `트랜스코딩`이라고 한다.
> 예로 고해상도 이미지를 저해상도 이미지로, 광고가 있는 페이지를 없는 페이지로 변환하는 것을 들 수 있다.

#### 포맷 변환
포맷 변환은 데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것이다.

포맷 변환은 내용 협상 헤더에 의해 주도된다. 내용 변환이나 트랜스코딩은 컨텐츠 인코딩이나
전송 인코딩과는 다르다.

내용 변환과 트랜스코딩은은 특정 접근 장치에서 컨텐츠를 볼 수 있도록 하기 위한 것이며,
컨텐츠 인코딩과 전송 인코딩은 컨텐츠의 효율적이고 안전한 전송을 위한 것이다.

#### 정보 합성
문서에서 정보의 요점을 추출하는 것을 `정보 합성(information synthesis)`이라고 한다.
이는 트랜스코딩 과정에서 유용할 수 있다.
 
예로 각 절의 제목에 기반한 문서의 개요 생성이나 페이지 내의 광고 및 로고 제거를 들 수 있다.

#### 컨텐츠 주입
포맷 변환과 정보 합성은 웹 문서의 양을 줄이지만, 
`내용 주입 트랜스코딩(content-injection transcoding)`은 오히려 양을 늘린다.

예로 자동 광고 생성과 사용자 추적 시스템이 있다. 이런 종류의 트랜스코딩은 `동적`으로 이루어진다.

#### 트랜스코딩 vs 정적으로 미리 생성해놓기
트랜스코딩의 대안은 웹 서버에 웹페이지의 여러 가지 사본을 만드는 것이다.

그러나 이것은 현실적인 기법이 못 된다. 페이지의 작은 변화에도 여러 페이지를 수정해야 되고,
각 페이지의 모든 버전을 저장하고자 많은 공간을 사용하게 된다.

이보다 루트 페이지를 필요할 때마다 변환하는 것이 더 쉬운 해결책이다. 
웹 서버보다 저렴한 프록시나 캐시에 있는 외부 에이전트에 의해 변환이 수행될 수 있고,
처리를 제3자에게 맡겨 웹 서버의 부담을 덜 수 있다.
 
그러나 이는 컨텐츠 제공 대기시간 증가로 추가적인 비용이 발생할 수 있다.

## 다음 단계
---
내용 협상은 두 가지 이유로 `Accept`나 `Content` 관련 헤더들에서 끝나지 않는다.
- HTTP의 내용 협상은 성능 제약을 초래한다. 베리언트 탐색이나, 서버의 추축은 비용이 클 수 있다.

- HTTP는 내용 협상이 필요한 유일한 프로콜이 아니다. `미디어 스트리밍`과 `팩스`는
클라이언트와 서버가 클라이언트에게 최적의 층답을 하기 위해 고려해야 할 요소이다.
내용 협상 프로토콜이 TCP/IP 응용 프로토콜 위에서 만들어질 수 있는가에 대한 의문이 지속되고 있다.

## Reference
---
HTTP: The Definitive Guide