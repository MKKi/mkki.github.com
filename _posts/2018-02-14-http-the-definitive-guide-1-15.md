---
layout: post
title:  "[HTTP: The Definitive Guide] 15. 엔터티와 인코딩"
date:   2018-02-14 15:25:26 +0900
background: '/img/posts/02.jpg'
categories: http
---

## 메시지는 컨테이너, 엔터티는 화물
---
HTTP 메시지를 운송 시스템의 `컨테이너`라 한다면, HTTP 엔터티는 메시지의 실질적인 `화물`이다.

HTTP/1.1은 다음과 같이 10가지 주요 엔터티 헤더 필드를 정의하였다.

- `Content-Type` 엔터티에 의해 전달된 객체의 종류
- `Content-Length` 전달되는 메시지의 길이나 크기
- `Content-Language` 전달되는 객체와 가장 잘 대응되는 자연어
- `Content-Encoding` 객체 데이터에 대해 행해진 압축과 같은 변형
- `Content-Location` 요청 시점을 기준으로, 객체의 또 다른 위치
- `Content-Range` 부분 엔터티라면 전체에서 어느 부분에 해당하는지 정의
- `Content-MD5` 엔터티 본문의 컨텐츠에 대한 체크섬
- `Last-Modified` 서버에서 이 컨텐츠가 생성, 수정된 날
- `Expires` 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- `Allow` 이 리소스에 대해 어떤 요청 메서드가 허용되는지
- `ETag` 이 인스턴스에 대한 고유한 검사기
- `Cache-Control` 어떻게 이 문서가 캐시될 수 있는지에 대한 지사자
> `Etag`, `Cache-Control`은 엄밀히 말해 엔터티 헤더로 정의되지 않았다.

#### 엔터티 본문
`엔터티 본문`은 **가공되지 않은** 데이터만을 담고 있다. 다른 정보들은 모두 헤더에 담겨 있다.
따라서 `엔터티 헤더`는 그 데이터의 의미를 설명할 필요가 있다.

엔터티 본문은 헤더 필드의 끝을 의미하는 `빈 CRLF` 줄 바로 다음부터 시작한다. `16진수 값`들은 텍스트와 이미지
엔터티의 정확한 내용을 알려준다.

## Content-Length: 엔터티의 길이
---
Content-Length 헤더는 메시지의 엔터티 본문의 크기를 `바이트` 단위로 나타낸다. 어떻게 인코딩 되었든 상관없이
크기를 표현할 수 있다.

Content-Length 헤더는 메시지를 `청크 인코딩`으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는
필수적으로 있어야 한다. 서버 충돌로 인한 `메시지 잘림 검출`과 `지속 커넥션`을 공유하는 메시지를 분할하고자 할 때
필요하기 때문이다.

#### 잘림 검출
오래된 버전의 `HTTP`는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다. 그러나 `Content-Length`가 없다면 커넥션이
정상적으로 닫힌 것인지 구분하지 못한다.

`메시지 잘림`은 `캐싱 프록시 서버`에서 특히 취약하다. 만약 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인삭하지
못했다면, 캐시는 결함이 있는 컨텐츠를 저장하고 계속해서 제공하게 될 것이다.

이러한 일을 방지하고자 `캐싱 프록시 서버`는 명시적으로 `Content-Length` 헤더를 갖고 있지 않은 HTTP 본문은 캐시하지 않는다.

#### 잘못된 Content-Length
Content-Length가 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다. `HTTP/1.1`에서는 사용자 에이전트가
잘못된 길이를 받고 이를 인지했을 때, 사용자에게 알려주게 되었다.

#### Content-Length와 지속커넥션
Content-Length는 `지속 커넥션`을 위해 필수다. 이는 클라이언트에게 메시지 하나가 어디서 끝나고, 다음 시작은 어디인지 알려준다.

커넥션은 `지속적`이기에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다.
따라서 HTTP 애플리케이션은 `엔터티 본문`의 길이와 끝을 인식하고자 `Content-Length` 헤더를 활용한다.
> `청크 인코딩`을 사용하는 경우는 예외이다. 
청크 인코딩은 데이터를 특정 크기를 갖는 `청크`들로 쪼개어 보내며, `Content-Legnth` 헤더를 필요로 하지 않는다.

#### 컨텐츠 인코딩
`HTTP`는 보안을 강화하거나 압축을 통해 `공간`을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해준다.

만약 본문의 컨텐츠가 인코딩되어 있다면, Content-Length 헤더는 원본이 아닌 인코딩된 본문을 바이트 단위로 정의한다.

`HTTP/1.1` 명세에서 그 어떤 헤더도 인코딩 전 원본의 길이를 보내고자 사용되지 않는다.
클라이언트가 수행한 디코딩 과정의 검증을 어렵게 하기 때문이다.
> `Content-MD5` 헤더도 인코딩된 문서의 MD5를 담는다. 그러나 자주 사용되지 않는다.

#### 엔터티 본문의 길이 판별을 위한 규칙
다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 규칙들이다.

- 본문을 갖지 못하는 타입의 HTTP 메시지에서는, Content-Length 헤더가 **무시된다**. 만약 존재하더라도 단순히 부가정보에
불과하며, 실제 본문의 길이를 서술하지 않는다.
> 대표적인 예는 `HEAD` 응답이다. `1XX`, `204`, `304` 응답 또한 본문을 갖지 않는다.

- 메시지가 `Transfer-Encoding` 헤더를 포함하고 있고 커넥션이 닫혀 먼저 끝나지 않는다면, 메시지는 `0바이트 청크`라
불리는 패턴으로 끝나야 한다. 만약 이 헤더가 포함된 메시지를 받았다면 Content-Length 헤더는 무시되어야 한다.

- 메시지가 `multipart/byteranges` 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 메세지는 각자가 스스로의 크기를 정의한다. 
따라서 수신자가 이를 해석할 수 있다는 사실을 송신자가 알기 전까지는 이 미디어 타입을 절대 보내서는 안된다.
> 해당 규칙은 `HTTP/1.1` 명세에서 이 규칙은 삭제되었다.

- 위의 규칙에 해당하지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다. 실질적으로 커넥션은 오직 서버만이 닫을 수 있다.
클라이언트가 커넥션을 닫아버리면 서버가 응답을 돌려줄 방법이 없기 때문이다.
> 클라이언트는 출력 채널만을 닫는 절반 끊기를 할 수도 있지만, 모든 서버에 설계된 것이 아니며 공식 명세에도 관련된 내용은 없다.

- `HTTP/1.0` 애플리케이션과의 호환을 위해, 본문을 갖는 `HTTP/1.1` 요청은 Content-Length 헤더를 포함해야 한다.
없는 경우에 메시지의 길이를 판별할 수 없다면 `400 Bad Request`를, 유효한 Content-Length 헤더를 요구하고 싶다면
`411 Length Required` 응답을 보내도록 권고된다.

## 미디어 타입과 캐릭터셋(Charset)
---
`Content-Type` 헤더 필드는 엔터티 본문의 `MIME 타입`을 기술한다. MIME 타입은 전달되는 데이터 메체의 기저 형식의 표준화된 이름이다.
클라이언트 애플리케이션은 컨텐츠를 해독하고 처리하고자 이를 이용한다.
> MIME 타입은 `text/html`과 같이, `주 미디어 타입`과 이를 구체적으로 기술하는 `부 타입`으로 구성된다.

Content-Type 헤더는 엔터티가 컨텐츠 인코딩을 거친 후에도 여전히 `엔터티 본문`의 미디어 타입을 명시한다는 점에서 중요하다.

#### 텍스트 매체를 위한 문자 인코딩
Content-Type 헤더는 내용의 타입을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다. 엔터티의 `비트 집합`을 텍스트 파일의
글자들로 변환하기 위한 `charset` 매개변수가 대표적인 예이다.
~~~
    Content-Type: text/html; charset=iso-8859-4
~~~

#### 멀티파트 미디어 타입
MIME 멀티파트 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
각 구성요소는 자신에 대해 서술하는 헤더를 포함한다. 이들은 서로 이어져 있으며, `문자열 하나`로 경계가 식별된다.

HTTP는 멀티파트 본문도 지원한다. 그러나 `폼(form)`을 채워 제출할 때와 문서의 일부분을 보내는 `범위 응답`을 할 때에만 사용된다. 

#### 멀티파트 폼 제출
HTTP `폼(form)`을 채워 제출하면, 가변 길이 `텍스트 필드`와 `객체`는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.

예를 들어, 사용자가 텍스트와 사진을 폼에 채워 보낸다고 하자.
이는 `Content-Type: multipart/form-data`나 `Content-Type: multipart/mixed` 헤더에 함께 실어 보내질 것이다.
~~~
    Content-Type: multipart/form-data; boundary=[abcdefg]
    
~~~

여기서 `boundary` 매개변수는 본문의 서로 다른 부분을 구분하기 위한 `구분자`로 쓰인다.

#### 멀티파트 범위 응답
범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있다. 이러한 응답은 `Content-Type: multipart/byteranges` 헤더와
각각 다른 범위를 담고 있는 `멀티파트 본문`이 함께 온다.

## 컨텐츠 인코딩
---
HTTP 애플리케이션은 종종 컨텐츠를 보내기 전에 `인코딩`을 하려고 한다. 느린 속도를 보완하고자 큰 문서를 `압축`하거나,
허가받지 않은 자가 접근할 수 없도록 컨텐츠를 `암호화`할 수도 있다.

이러한 종류의 인코딩은 발송하는 쪽에서 컨텐츠에 적용한다. 컨텐츠 인코딩이 끝난 데이터는 `엔터티 본문`에 담아 수신자에게 보내진다.

#### 컨텐츠 인코딩 과정
1. 웹 서버가 원본 `Content-Type`과 `Cotnet-Length` 헤더를 수반한 원본 응답 메시지를 생성한다.

2. 컨텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 만약 압축되었다면, 
`Content-Type`은 같지만 `Content-Length`는 다르다. 또한, `Content-Encoding` 헤더를 메시지에 추가하여 디코딩할 수 있도록 한다.

3. 수신 측 애플리케이션은 인코딩된 메시지를 받아서 `디코딩`하고 원본을 얻는다.

#### 컨텐츠 인코딩 유형
HTTP는 몇 가지 표준 컨텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.

인코딩은 각 컨텐츠 인코딩 알고리즘에 고유한 `토큰`을 할당하는 [IANA][IANA]를 통해 표준화된다.

`Content-Encoding` 헤더는 표준화된 토큰 값을 이용해서 인코딩에 사용된 `알고리즘`들을 기술한다.
다음은 자주 쓰이는 컨텐츠 인코딩 토큰들이다.
- `gzip` 엔터티에 GNU zip 인코딩이 적용되었음을 의미한다.
- `compress` 엔터티에 유닉스 파일 압축 프로그램인 compress가 실행되었음을 의미한다.
- `deflate` 엔터티가 zlib 포맷으로 압축되었음을 의미한다.
- `identity` 엔터티에 어떤 인코딩도 수행되지 않았음을 의미한다. Content-Encoding 헤더가 없을 때의 기본값이다.
> `gzip`, `compress`, `deflate` 인코딩은 무손실 압축 알고리즘이다. 이 중 `gzip`이 가장 효율적이고 널리 쓰인다.

#### Accept-Encoding 헤더
서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 원하는 인코딩 목록을
`Accept-Encoding` 요청 헤더를 통해 전송한다.

만약 HTTP 요청에 해당 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다.
> `Accept-Encoding: *`을 전달한 경우와 같다.

아래 예시에서 `Q(quailty)` 매개변수는 선호도를 나타내며, 0.0부터 1.0 사이의 값을 지정할 수 있다.
또한, `identity` 인코딩 토큰은 `Accept-Encoding` 헤더에서만 사용할 수 있다.
~~~
    Accept-Encoding: gzip; q=1.0, identity; q=0.5, *; q=0
~~~

## 전송 인코딩과 청크 인코딩
---
`전송 인코딩`도 엔터티 본문에 적용되는 변환이지만, 구조적인 이유 때문에 적용되는 것이며 컨텐츠의 포맷과는 **독립적**이다.
> 컨텐츠 인코딩은 `엔터티 본문`만을 인코딩한다. 전송 인코딩은 `메시지 전체`에 적용된다.

#### 안전한 전송
전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 **안전한 전송**을 위해 존재했다.

HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 몇 가지 밖에 없다. 그 중 두 가지는 다음과 같다.
- 몇몇 `게이트웨이 애플리케이션`과 `컨텐츠 인코더`는 컨텐츠를 먼저 생성하지 않고서는 메시지 본문의 **최종 크기**를 판단할 수 없다.
이 서버들은 대개 그 사이즈를 알기 전에, 데이터의 끝을 알리는 `꼬릿말`을 포함시켜 전송 인코딩으로 데이터를 보내려고 한다.

- 공용 전송 네트워크로 메시지 컨텐츠로 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 바꾸는 방법도 있다.
그러나 `SSL`과 같은 전송 계층 보안 방식이 있기에 전송 인코딩 보안은 잘 쓰이지 않는다.

#### Transfer-Encoding 헤더
전송 인코딩을 제어하고 서술하기 위한 헤더는 단 두 개뿐이다.
- `Transfer-Encoding` 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
- `TE` 어떤 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.

모든 전송 인코딩 값은 대소문자가 구별된다. HTTP/1.1은 `Transfer-Encoding`과 `TE` 헤더 필드에 전송 인코딩 값을 사용한다.
최신 HTTP 명세는 `청크 인코딩`만을 정의한다.

TE 헤더는 `Accept-Encoding` 헤더와 마찬가지로 `Q` 값을 가질 수 있다. 그러나 HTTP/1.1 명세는 청크 인코딩의 Q 값이 `0.0`인
것을 금한다.

#### 청크 인코딩
청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 청크를 **순차적**으로 보낸다.
이를 이용하면 메시지를 보내기 전에 **전체 크기**를 알 필요가 없어진다.

본문이 동적으로 생성되고, 서버는 일부를 `버퍼`에 담아 크기와 함께 전송한다. 본문 전체를 모두 보낼 때까지
이를 반복한다.

청크 인코딩이 전송 인코딩의 한 형태이며, 본문이 아닌 `메시지의 속성`임에 주목해야 한다.
멀티파트 인코딩은 `본문의 속성`이며 청크 인코딩과는 완전히 분리되어 있다.

#### 청크와 지속 커넥션
지속 커넥션에서 본문을 쓰기 전에 반드시 `Content-Length` 헤더에 본문의 길이를 담아서 보내줘야 한다.
그러나 컨텐츠가 서버에서 동적으로 생성되는 경우에는 본문의 길이를 알아내는 것이 불가능하다.

청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이를 해결해준다.
서버는 크기가 `0`인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다. 

청크 인코딩은 HTTP 응답 헤더 블록으로 시작하고, 이어서 청크의 스트림이 온다.
각 청크는 길이 값과 각 청크에 대한 데이터를 담고 있다. 

길이 값은 `16진수` 형식으로 되어 있고 데이터와 `CRLF`로 분리된다. 데이터는 `바이트` 단위로 측정되고
청크 끝의 CRLF 문자열뿐 아니라 길이 값과 데이터 사이의 CRLF 문자열도 길이에 포함하지 않는다.

마지막 청크는 본문의 끝을 의미하기 위해 길이가 0이다.
~~~
    // message header
    HTTP/1.1 200 OK<CR><LF>
    Content-type: text/plain<CR><LF>
    Transfer-encoding: chunked<CR><LF>
    Trailer: Content-MD5<CR><LF>
    <CR><LF>
    
    // chunk #1
    27<CR><LF>
    We hold these truths to be self-evident<CR><LF>
    
    ...
    
    // last chunk
    0<CR><LF>
    
    // trailer
    Content-MD5: gjpei54p25tjisgj3p4utjgrj53<CR><LF>    
~~~

클라이언트는 또한 청크 인코딩된 데이터를 서버로 전송한다. 서버가 청크 인코딩을 지원하는지 모르기에, 청크 요청이
`411 Length Required` 응답으로 거절당하는 것에 대비해야 한다.
> 서버는 클라이언트에게 `TE` 헤더를 포함시켜 보내지 않는다.

#### 청크 인코딩된 메시지의 트레일러
다음 중 하나 이상의 조건을 만족하면 청크 메시지에 `트레일러`를 추가할 수 있다.
- 클라이언트의 `TE` 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며, 해당 트레일러의 컨텐츠는 선택적인 `메타 데이터`라
클라이언트가 무시하고 버려도 되는 경우

`트레일러`는 본문의 컨텐츠가 먼저 생성되야 한다는 등의 이유로, 메시지 시작 시점에서는 알 수 없는 **추가적인** 헤더 필드를
담을 수 있다.

마지막 청크 다음에 `Trailer` 헤더에 나열했던 헤더들이 온다. `Transfer-Encoding`, `Trailer`, `Content-Length`를 제외한
모든 헤더를 보낼 수 있다.

#### 컨텐츠와 전송 인코딩의 조합
컨텐츠 인코딩과 전송 인코딩은 **동시에** 사용될 수 있다. 송신자는 컨텐츠 인코딩을 사용해서 데이터를 압축하고,
이를 청크 인코딩하여 전송한다.

수신자가 본문을 `재구축`하는 절차는 반대이다. 청크 데이터를 디코딩한 후, 이를 컨텐츠 디코딩하여 본문을 얻는다.

#### 전송 인코딩 규칙
전송 인코딩이 메시지 본문에 적용될 때 몇 가지 규칙이 **반드시** 적용되야 한다.

- 전송 인코딩의 집합은 반드시 `chunked`를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.

- 청크 전송 인코딩이 사용되었다면, 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.

- 청크 전송 인코디은 반드시 메시지 본문에 한 번 이상 적용되야 한다.

이 규칙은 수신자가 메시지의 `전송 길이`를 알아낼 수 있게 해준다. 전송 인코딩은 `HTTP/1.1`에서 소개된 기능이다.

따라서 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의해야 한다. 반대로 서버가 이해할 수 없는
전송 인코딩된 메시지를 받았다면, 서버는 `501 Unimplemented` 상태 코드로 응답해야한다.

마지막으로 HTTP/1.1 애플리케이션은 청크 인코딩만은 반드시 지원해야 한다.

#### 시간에 따라 바뀌는 인스턴스
웹 객체는 동적이다. 똑같은 요청이라도 시간에 따라 다른 버전의 객체를 가리킬 수 있다.

HTTP 프로토콜은 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이를 `인스턴스 조작(instance manipulation)`
이라 한다. 대표적인 두 가지가 `범위 요청`과 `델타 인코딩`이다.

두 가지 모두, 클라이언트가 자신의 리소스 사본이 서버의 것과 일치하는지 판단하고 상황에 따라 새 인스턴스를 요청할 수 있도록
해준다.

## 검사기와 신선도
---
#### 신선도
서버는 클라이언트에게 컨텐츠를 `캐시`할 기간과 `신선도`의 대한 정보를 줄 것이다. 서버는 `Expires`나 `Cache-Controll` 헤더를
통해 이러한 정보를 제공할 수 있다.

Expires 헤더는 문서가 만료되어 더 이상 신선하지 않게 되는 `날짜`를 명시한다. 이를 제대로 사용하기 위해서는 시계를 반드시 `동기화
`시켜야 하지만, 이것이 쉽지는 않다.
~~~
    Expires: Sun Mar 18 23:59:59 GMT 2001
~~~

`Cache-Control` 헤더는 `최대 수명`을 문서가 서버를 떠난 후로부터의 총시간을 `초 단위`로 정한다. 수명은 시계 동기화에 의존하지 않는
`상대 시간`으로 더 정확한 결과를 말해준다.

#### 조건부 요청과 검사기
캐시의 사본이 요청되었을 때 신선하지 않다면, 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있다.

동일한 요청으로 네트워크 대역폭을 낭비하고 서버에 부하를 주는 것을 막기 위해서, HTTP는 클라이언트에게
리소스가 바뀐 경우에만 사본을 요청하는 `조건부 요청`이라는 방법을 제공한다.

`If-`로 시작하는 조건부 헤더는 조건이 `참`일 경우에만 수행된다. 만약 조건이 거짓이라면, 서버는 에러 코드를 반환한다.

HTTP는 검사기를 약한 검사기와 강한 검사기 두 가지로 분류한다.
`약한 검사기`는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우도 있다. `강한 검사기`는 언제나 고유하게 식별한다.

약한 검사기의 예로 객체의 바이트 단위 크기가 있다. 리소스 컨텐츠에 대한 `암호 체크섬`은 강한 검사기다.

최종 변경 시각은 약한 검사기로 간주되는데 정확도가 `최대 1초`에 불과하기 때문이다. 반면 `ETag` 헤더는 강한 검사기이다.
서버는 매 변경마다 구분되는 값을 넣어두기 때문이다.

#### 범위 요청
HTTP는 클라이언트가 문서의 **일부분이나 특정 범위**만 요청할 수 있도록 해준다. 예를 들어 클라이언트가 다음과 같은 범위 요청을 했다고 하자.
~~~
    GET /bigfile.html HTTP/1.1
    Host: www.example.com
    Range: bytes=4000-
    User-Agent: Mozilla/4.61 [en] (WinNT; I)
    ...
~~~

클라이언트는 처음 4,000바이트 이후의 부분을 요청하고 있다. 이 예시에서 클라이언트가 하나의 요청으로 **여러 범위**를 요청했을 때,
응답은 `멀티파트 본문`, `Content-Type: multipart/byteranges` 헤더와 함께 하나의 엔터티로 돌아온다.

서버는 클라이언트에게 범위를 받아들일 수 있는지를 `Accept-Range` 헤더를 응답에 포함시키는 방법으로 알려줄 수 있다.
이 헤더의 값은 측정의 단위이며, 주로 `바이트`이다.

범위 요청은 객체의 **특정 인스턴스**를 클라이언트와 서버 사이에서 교환하는 `인스턴스 조작`이라는 것에 주의해야한다.
즉, 범위 요청은 클라이언트와 서버가 `같은 버전`의 문서를 갖고 있을 때만 의미가 있음을 말해준다.

## 델타 인코딩
---
웹 페이지의 각기 다른 `버전`들은 그 페이지에 대한 각기 다른 `인스턴스`다.

클라이언트에게 최신 인스턴스를 제공할 때, 전체를 보내는 대신 사본의 변경 부분만을 서버가 보낸다면
클라이언트는 더 빠른 응답을 얻을 수 있을 것이다.

델타 인코딩은 이처럼 변경된 부분만 통신하여 **전송량을 최적화**하는 HTTP 프로토콜의 `확장`이다.
델타 인코딩 역시 `인스턴스 조작`이다. 클라이언트와 서버가 특정 객체 인스턴스들의 정보 교환에 의존하기 때문이다.

클라이언트는 페이지의 어떤 버전을 갖고 있는지 서버에게 말해주어야 하는데, 이는 클라이언트가 페이지의 최신 버전에 대한
`델타(변경된 부분)`를 받아들일 **의사가 있음**을 의미한다.

그리고 클라이언트는 자신이 갖고 있는 현재 버전에 델타를 적용하기 위해 어떤 알고리즘을 알고 있는지도 말해주어야 한다.

이에 서버는 클라이언트의 버전을 갖고 있는지, 그리고 어떻게 델타를 계산할 것인지에 대해 체크해야 한다.
> 클라이언트의 객체와 최신 버전 객체 간의 델타를 계산해주는 여러 알고리즘이 존재한다.

이후 델타를 계산하여 클라이언트에게 보내준다. 그리고 서버가 델타를 보내고 있음을 클라이언트에게 알려주고,
페이지의 최신 버전에 대한 `새 식별자`를 명시해야 한다.

클라이언트는 자신이 갖고 있던 버전에 대한 식별자인 `ETag` 헤더 값을 `If-None-Match` 헤더에 담아 조건부 요청을 한다.
동시에 클라이언트는 `A-IM` 헤더를 보내서 페이지에 대한 델타를 받아들일 수 있음을 알려줄 수도 있다.
> `A-IM`은 `Accept-Instance-Manipulation`의 약자이다.

서버는 클라이언트에게 요청 객체 자체가 아닌 인스턴스 조작을 보내고 있음을 말해주는 `226 IM Used` 상태 코드,
델타를 계산하는데 사용한 알고리즘을 명시한 `IM` 헤더, 새로운 `ETag`, 그리고 델타를 계산하는데 기반이 된 문서의
ETag를 지정한 `Delta-Base` 헤더를 되돌려준다.

#### 인스턴스 조작, 델타 생성기 그리고 델타 적용기
클라이언트는 `A-IM` 헤더에 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다.
서버는 `IM` 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다.

다음은 `IANA`에 등록된 인스턴스 조작의 종류들이다.
- `vcdiff` vcdiff 알고리즘을 이용한 델타
- `diffe` 유닉스 diff-e 명령을 이용한 델타
- `gdiff` gdiff 알고리즘을 이용한 델타
- `gzip` gzip 알고리즘을 이용한 압축
- `deflate` deflate 알고리즘을 이용한 압축
- `range` 현재 응답이 부분 컨텐츠임을 말해주기 위해 서버 응답에서 사용된다.
- `identit` 클라이언트가 identity 인스턴스 조작을 받아들일 의사를 말해주기 위해 사용된다.

`델타 생성기`는 `A-IM` 헤더에 지정된 알고리즘를 이용하여 기저 문서와 최신 인스턴스 사이의 델타를 계산한다.
자세한 내용은 공식 명세인 [RFC 3229][delta-encoding]를 참고하자.

델타 인코딩의 `A-IM`, `IM` 헤더는 복수 개의 인스턴스 조작들을 지정할 수 있다. 또한 문서는 여러 번의 인스턴스 조작을 거쳐
클라이언트에게 반환될 수 있다.
> 예로 `vcdiff` 알고리즘으로 생성된 델타는 `gzip` 알고리즘으로 압축될 수 있다.

하지만 델타 인코딩은 구현하기 까다롭다. 이를 지원하는 서버는 자신이 제공하는 페이지가 변경되는 **매 순간의 사본**을
모두 유지해야 하기 때문이다.

결국, 서버는 반드시 클라이언트가 가지고 있던 이전 버전의 사본들을 유지해고자 `저장 공간`을 늘려야한다.
이는 전송량 감소로 얻은 이득을 **무의미**하게 한다.

## Reference
---
HTTP: The Definitive Guide

[IANA]: https://ko.wikipedia.org/wiki/IANA
[delta-encoding]: https://tools.ietf.org/html/rfc3229