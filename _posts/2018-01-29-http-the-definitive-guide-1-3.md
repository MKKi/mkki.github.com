---
layout: post
title:  "[HTTP: The Definitive Guide] 3. HTTP 메시지"
date:   2018-01-29 17:37:22 +0900
background: '/img/posts/02.jpg'
categories: http
---

## 메시지의 흐름
---
`HTTP 메시지`는 HTTP 애플리케이션 간에 주고받은 **데이터의 블록들**이다.
이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고, 그 다음에 **선택적으로** 데이터가 온다.

HTTP는 `인바운드`와 `아웃바인드`라는 용어를 **트랙잭션 방향을 표현**하기 위해 사용한다. 
메시지가 서버 방향으로 향하는 것이 인바운드로 이동하는 것, 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.

요청 메시지냐 응답메시지냐에 관계없이 **모든 메시지는 다운스트림**으로 흐른다. 메시지의 발송자가 수신자의 업스트림이다.

## 메시지의 각 부분
---
HTTP 메시지는 어떤 메시지인지 서술하는 `시작줄`, 속성이 서술된 `헤더`, 데이터를 담고 있는 `본문` 블럭으로 구성되어있다. 

시작줄과 헤더의 각 줄은 캐리지리턴과 개행 문자로 구성된 줄바꿈 문자열(CRLF)으로 끝난다. 
본문은 이진데이터와 텍스트를 포함할 수 있고, **비어있을 수도 있다.**

## 메시지 문법
---
요청 메시지는 `<메서드><요청 URL><버전> - <헤더> - <엔터티 본문>` 형식으로, 응답 메시지는
`<버전><상태코드><사유 구절> - <헤더> - <엔터티 본문>` 형식으로 구성되어있다.

메서드는 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 **동작**이다.

요청 URL은 요청 대상이 되는 리소스를 지칭하는 **완전한 URL 혹은 경로 구성요소**이다. 경로 구성요소
라고 하더라도 절대 경로이기만 하면 대체로 문제가 없다.

버전은 해당 메시지에서 사용하고 있는 HTTP의 버전이다. `HTTP/<메이저>.<마이너>`의 형식이다.

상태코드는 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자이다. 각 코드의 **첫 번째 자릿 수**는 
상태의 일반적인 분류인 `성공`, `에러` 등을 나타낸다.

사유구절(reason-phrase)은 오로지 사람에게 읽히기 위한 목적으로만 존재하는 짧은 문구이다.

헤더는 `이름`, `콜론(:)`, `공백`, `값`, `CRLF`가 순서대로 나타나는 0개 이상의 헤더로 이루어져있다.

엔터티 본문은 임의의 데이터 블록을 포함한다. **헤더나 엔티니 본문이 없더라도** HTTP 헤더는 항상
CRLF로 끝나야한다. 그러나 역사적으로 CRLF가 없는 메시지도 있으므로, 이러한 구현체와의 호환을
위해 CRLF 없이 끝나는 메시지도 받아들일 수 있도록 해야한다.

## 시작줄
---
모든 HTTP 메시지는 `시작줄`로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지 말해주고, 응답
메시지의 시작줄은 무슨일이 일어났는지 말해준다.

`HTTP/1.0` 이전에는 요청줄에 HTTP 버전이, 응답에 응답줄이 들어있을 **필요가 없었다.**

요청의 시작줄은 `메서드`로 시작하며, 서버에게 무엇을 해야 하는지 말해준다. 자주 사용되는 7가지 메서드가 존재하며, 
모든 서버가 이를 구현한 것은 아님에 주의해야한다. 

더 나아가, HTTP는 쉽게 확장될 수 있도록 설계되어있기에, 
서버는 그들만의 메서드를 추가로 구현했을 수도 있다. 이를 `확장 메서드`라 한다.

| 메서드  	| 설명                                                    | 본문 	|
|---------	|-------------------------------------------------------- |--------------   |
| HEAD    	| 서버에서 어떤 문서에 대해 헤더만 가져온다.              | X           	|
| POST    	| 서버가 처리해야 할 데이터를 보낸다.                     | O           	|
| PUT     	| 서버에 요청 메시지의 본문을 저장한다.                   | O           	|
| TRACE   	| 메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적한다. | X           	|
| OPTIONS 	| 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | X           	|
| DELETE  	| 서버에서 문서를 제거한다.                               | X           	|

상태 코드는 각 응답 메시지의 시작줄에 담겨 반환된다. 다음은 `상태코드`의 종류를 나타내는 표이다.

| 전체 범위  | 정의된 범위  | 분류                          |
|----------- |------------- |------------------------------ |
| 100-199    | 100-101      | 정보                          |
| 200-299    | 200-206      | 성공                          |
| 300-399    | 300-305      | 리다이렉션(리소스가 옮겨짐)   |
| 400-499    | 400-415      | 클라이언트 에러(잘못된 요청)  |
| 500-599    | 500-505      | 서버 에러                     |

## 헤더
---
`HTTP 헤더` 필드는 요청과 응답 메시지에 추가 정보를 더한다. 기본적으로 `이름/값 쌍`의 목록이다.

HTTP 헤더 명세는 `여러 헤더 필드`를 정의한다. 또한, 애플리케이션은 자유롭게 자신만의 헤더를 만들
어낼 수 있다.

HTTP 헤더는 `일반 헤더`, `요청 헤더`, `응답 헤더`, `Entity 헤더`, `확장 헤더`로 분류된다. 다음은 자주 사용
되는 헤더의 예이다.

| 헤더의 예                               | 설명                                                     |
|-----------------------------------------|----------------------------------------------------------|
| Date: Tue, 3 Oct 1997 02:16:03 GMT      | 서버가 응답을 만들어 낸 시각                             |
| Content-length: 15040                   | 15,040바이트의 데이터를 포함한 엔터티 본문               |
| Content-type: image/gif                 | 엔터티 본문은 GIF 이미지다.                              |
| Accept: image/gif, image/jpeg,text/html | 클라이언트는 GIF, JPEG 이미지와 HTML을 받아들일 수 있다. |

긴 헤더 줄은 여러 줄로 쪼개서 가독성을 좋게 만들어줄 수 있는데, 앞에 최소 하나의 `스페이스`, `탭` 문자를 넣어주어야한다.

## 엔터티 본문
---
엔터티 본문은 HTTP 메시지의 화물로 비유할 수 있다. HTTP 메시지는 이미지, 비디오, HTML 문서,
소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 디지털 데이터를 나를 수 있다.

## HTTP/0.9
---
HTTP 프로토콜의 **초기 버전**이다. 오늘날 HTTP가 갖고 있는 요청과 응답 메시지의 시초이지만, 훨씬
단순한 프로토콜로 구성되어 있다. 요청은 그저 메서드와 요청 URL만을 갖고 있고, 응답은 오직 엔터티
로만 되어 있다. `버전 정보`나 `상태 코드`, `사유 구절`도 없으며, `헤더`도 포함되어 있지 않다.

그렇기에 `HTTP/0.9`로는 다양한 상황에 대응할 수 없으며, 여러 기능들과 애플리케이션들도 구현할
수 없다. 하지만 여전히 이를 사용하는 클라이언트와 서버들이 있기에, 이러한 제약을 인지해야 한다.

## 메서드
---
모든 서버가 모든 메서드를 구현하지 않는다는 것에 유의해야 한다. `HTTP/1.1`버전과 호환되고자 한
다면, 서버는 자신의 리소스에 대해 `GET`과 `HEAD` 메서드만을 구현하는 것으로 충분하다. 비록 서버가
모든 메서드를 구현하지 않았다고 해도 메서드는 대부분 제한적으로 사용될 것이다.

## 안전한 메서드(Safe Method)
---
`GET`과 `HEAD` 메서드는 안전하다고 할 수 있다. 이들의 결과로 서버에 어떤 작용도 없기 때문이다. 작
용이 없다는 것은, HTTP 요청의 결과로 인해 서버에게 일어나는 일은 아무것도 없다는 의미이다.

안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들
에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

## 자주 사용되는 메서드
---
GET
: `GET`은 가장 흔하게 쓰이는 메서드이다. 주로 서버에서 리소스를 달라고 요청하기 위해 쓰인다.

HEAD
: `GET`처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. 
클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.(리소스 타입, 상태 코드, 리소스 변경 유무 확인)

: 또한, 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

PUT
: `PUT` 메서드는 서버에 문서를 쓴다. 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 
이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

: `PUT`은 콘텐츠를 변경할 수 있게 해주기에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것이다.

POST
: `POST` 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. 실제로, HTML 폼을 지원하기 위해 흔히 사용된다. 
채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳
(예를들면 그 데이터를 처리할 서버 게이트웨이 프로그램)에 보낸다.

TRACE
: 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽과 프록시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. 
이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다. 
`TRACE` 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

: TRACE 요청은 목적지 서버에서 `루프백(loopback)` 진단을 시작한다. 
요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 요청을 되돌려준다. 
이에 클라이언트는 자신이 보낸 메시지가 망가졌거나 수정되었는지, 그렇다면 어떻게 변경되었는지 확인할 수 있다.

: `TRACE` 메서드는 주로 **진단**을 위해 사용된다. 그러나 중간 애플리케이션이 다른 종류의 요청을 일관
되게 다룬다고 가정하는 문제가 있다.

: TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다. TRACE 응답의 엔터티 본문에는 서버가 받은
요청이 그대로 들어있다.

OPTIONS
: `OPTIONS` 메서드는 웹 서버에게 여러 종류의 지원 범위에 대해 물어본다.

: 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있기에, 
실제로 리소스에 접근하지 않고도 해당 리소스에 접근할 수 있는 최적의 수단을 클라이언트 애플리케이션에게 제공한다.

DELETE
: `DELETE` 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 그러나 클라이언트
는 삭제가 수행되는 것을 보장하지 못한다. 왜냐하면 HTTP 명세는 서버가 클라이언트에게 알리지 않고
**요청을 무시하는 것을 허용**하기 때문이다.

> 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다. HTTP는 필요에 따라 확장해도 문제가 없도
록 설계되었고, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오작동을 유발하지 않는다.

## 상태 코드
---
HTTP `상태 코드`는 크게 다섯 가지로 분류된다. 이들은 클라이언트에게 그들의 **트랜잭션을 이해**할 수
있는 가장 쉬운 방법을 제공한다.

## 100-199: 정보성 상태 코드
---
`101 Switching Protocols` 상태 코드는 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가
프로토콜을 바꾸었음을 의미한다.

`100 Continue` 상태 코드는 HTTP 클라이언트 애플리케이션이 엔터티 본문을 전송하기 전에, 
그 엔티티 본문을 서버가 받아들일 것인지 확인하는 작업을 **최적화하기 위한 의도**로 도입된 것이다. 

만약, 클라이언트가 엔터티를 서버로 보내려고 하고, 
그 전에 100 Continue 응답을 기다리겠다면, 클라이언트는 값을 100-continue로 하는 `Expect 요청 헤더`를 보낼 필요가 있다. 
반대라면, 100-continue Expect 헤더를 보내지 않아야한다.

서버가 100-continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, **100 Continue 응답 혹은 에러 코드**로 답해야 한다. 
서버는 절대로 100-continue 응답을 **기다리지 않는 클라이언트**에게 100 Continue 상태 코드를 보내서는 안 된다.

서버가 100 Continue 응답을 보낼 기회를 갖기 전에 엔터티 일부 혹은 전체를 수신하였다면, 
서버는 이 상태 코드를 **보낼 필요가 없다.** 왜냐하면 클라이언트는 이미 계속 전송하기로 결정하였기 때문이다.
그러나 서버가 요청을 끝까지 다 읽은 후에도 그 요청에 대한 최종 응답을 보내야 한다. 여기서 100 Continue 상태는 생략해도 무관하다.

클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프록시는 몇 가지 해야할 일이 있다. 
만약 `다음 홉(next-hop)` 서버가 HTTP/1.1을 따르거나, 
어떤 버전을 따르는지 모른다면 Expect 헤더를 포함시켜서 요청을 다음으로 전달해야 한다. 

반대로 다음 홉의 서버가 **1.1 이전 버전**의 HTTP를 따르면, 프록시는 `417 Expectation Failed` 에러로 응답해야 한다.

그리고 클라이언트가 **HTTP/1.0 혹은 그보다 이전 버전**을 따른다면, 
프록시는 100 Continue 응답을 클라이언트에 전달하면 안 된다. 

이러한 정보들을 프록시가 기억하고 있다면, 100-continue 응답을 기대한 요청을 잘 다룰 수 있게 된다.

## 200-299: 성공 상태 코드
---
클라이언트가 요청을 보내면, 그 요청은 대개 성공한다. 
서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다. 

- `200 OK` 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다.

- `201 Created` 서버 개체를 생성하라는 요청을 위한 것. 
응답은 생성된 리소스에 대한 구체적인 참조가 담긴 Location 헤더와 함께 여러 URL을 엔터티 본문에 포함해야 한다.

- `202 Accepted` 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 
서버는 요청에 대한 상태와 해당 요청에 대한 처리가 언제 완료될 것인지에 대한 추정도 포함해야 한다.

- `203 Non-Authoritative Information` 엔터티 헤더에 들어가 있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 
중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보를 검증하지 못한 경우 이런 일이 발생한다.

- `204 No Content` 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 
주로 웹 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용한다.

- `205 Reset Content` 주로 브라우저를 위해 사용되는 코드이다. 
브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.

- `206 Partial Content` 부분 혹은 범위 요청이 성공했다. 
Content-Range와 Date 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 포함해야 한다.

## 300-399: 리다이렉션 상태 코드
---
리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주
거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.

만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 
어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태코드와 Location 헤더를 보낼 수 있다.

몇몇 리다이렉션 코드는 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.

- `300 Multiple Choices` 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환한다. 
사용자는 목록에서 원하는 하나를 선택할 수 있다. 서버는 Location 헤더에 선호하는 URL을 포함시킬 수 있다.

- `301 Moved Permanently` 요청한 URL이 옮겨졌을 때 사용한다. 
응답은 `Location 헤더`에 현재 리소스에 존재하고 있는 URL을 포함해야 한다.

- `302 Found` 301 상태 코드와 같다. 
그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 **임시로 가리키기 위한 목적**으로 사용해야 한다. 
이후의 요청은 원래 URL을 사용해야 한다.

- `303 See Other` 클라이언트에게 리소스를 **다른 URL**에서 가져와야 한다고 말해주고자 할 때 쓰인다. 
새 URL은 응답 메시지의 Location 헤더에 들어있다. 
이 상태 코드의 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다.

- `304 Not Modified` 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 
예로 If-Modified-Since 헤더에 조건을 주고, 해당 리소스에 수정사항이 없다면 이 코드는 리소스가 수정되지 않았음을 의미한다. 
304 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 된다.

- `305 Use Proxy`리소스가 반드시 프록시를 통해 접근되어야 함을 나타내기 위해 사용한다. 
프록시의 위치는 Location 헤더를 통해 주어진다. 클라이언트는 이 응답을 특정 리소스에 대한 것이라고만 해석한다.

- `307 Temporary Redirect` 302 코드와 같다.

302, 303, 307 상태 코드 간 유사한 점이 있지만, 
HTTP/1.0과 HTTP/1.1 애플리케이션에서 **해당 상태 코드를 다루는 방식**에서 차이점이 존재한다. 

HTTP/1.0에서는 리다이렉션 코드로 302를, HTTP/1.1에서는 리다이렉션 코드로 303을 사용한다. 이러한 혼란을 막기 위해 
HTTP/1.1 명세는 HTTP/1.1 클라이언트의 `일시적인 리다이렉트`를 위해 302 상태 코드 대신 **307 상태 코드**를 사용하라고 한다.

## 400-499: 클라이언트 에러 상태 코드
---
잘못 구성된 요청 메시지와 같이 많은 클라이언트 에러는 브라우저에 의해 처리된다.

- `400 Bad Request` 클라이언트가 잘못된 요청을 보냈다고 말해준다.

- `401 Unauthorized` 리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다.

- `402 Payment Required` 현재 사용되지 않는 상태 코드이다.

- `403 Forbidden` 요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다. 거부 사유를 설명하는 엔터티 본문을 포함시킬 수 있다. 그러나 보통 서버가 거절의 이유를 숨기고 싶을 때 사용한다.

- `404 Not Found` 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다. 종종, 클라이언트 애플리케이션이 사용자에게 보여주기 위한 엔터티가 포함된다.

- `405 Method Not Allowed` 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용한다. 요청한 리소스에 대해 어떤 메서드가 사용 가능한지 클라이언트에게 알려주기 위해 요청에 Allow 헤더가 포함되어야 한다.

- `406 Not Acceptable` 클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다.

- `407 Proxy Authentication Required`401 상태 코드와 같으나, 리소으에 대한 인증을 요구하는 프록시 서버를 위해 사용한다,

- `408 Request Timeout` 클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다. 타임아웃의 길이는 서버마다 상이하지만, 대개 충분히 길다.

- `409 Conflict` 서버는 요청이 충돌을 일으킬 염려가 있다고 생각할 때 이 상태 코드를 보낼 수 있다.

- `410 Gone` 404 상태 코드와 비슷하나, 서버가 한때 해당 리소스를 가지고 있었다는 점에서 다르다. 즉, 리소스가 제거되었다는 것을 알려주기 위해 사용한다.

- `411 Length Required` 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용한다.

- `412 Precondition Failed` 클라이언트가 조건부 요청을 했는데, 그 중 하나가 실패했을 때 사용한다. 조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생한다.

- `413 Request Entity Too Large` 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 받았을 때 사용한다.

- `414 Request URI Too Long` 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 받았을 때 사용한다.

- `415 Unsupported Media Type` 서버가 이해하거나 지원하지 못하는 타입의 엔터티를 받았을 때 사용한다.

- `416 Requested Range Not Satisfaible` 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었을 때 사용한다.

- `417 Expectation Failed` 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있을 경우 사용한다. 프록시나 다른 중개자 애플리케이션은 원서버가 요청의 기대를 만족시킬 수 없을 명확한 증거가 있다면 이 응답 코드를 전송할 수 있다.

## 500-599: 서버 에러 상태 코드
---
서버 자체에서 에러가 발생하는 경우 사용하는 상태 코드이다. 이는 클라이언트가 서버의 제한에 걸린
것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.

프록시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다. 프록시는 문제를
설명하기 위해 5XX 서버 에러 상태 코드를 생성한다.

- `500 Internal Server Error` 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다.

- `501 Not Implemented` 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다. (예를 들어 서버가 지원하지 않는 메서드를 사용했을 때)

- `502 Bad Gateway` 프록시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥드렸을 때 사용한다. (예를 들어 자신의 부모 게이트웨이에 접속하는 것이 불가능할 때)

- `503 Service Unavailable` 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미하고자 할 때 사용한다. 만약 서버가 언제 그 리소스를 사용할 수 있게 될지 알고 있다면, 서버는 Retry-After 헤더를 응답에 포함시킬 수 있다.

- `504 Gateway Timeout` 408 상태 코드와 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프록시에서 온 응답이라는 점이 다르다.

- `505 HTTP Version Not Supported` 서버가 지원할 수 없거나 지원하지 않는 버전의 프로토콜로 된 요청을 받았을 때 사용한다.

## 헤더
---
헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다. 헤더는 크게 다섯가지로 분류된다.

**1. 일반 헤더**
- 클라이언트와 서버 양쪽 모두가 사용한다. 이들은 클라이언트, 
서버 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.
> 예시 `Date: Tue, 3 Oct 1997 02:16:03 GMT`

**2. 요청 헤더**
- 요청 메시지를 위한 헤더다. 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.
> 예시 `Accept: */*`

**3. 응답 헤더**
- 클라이언트에게 정보를 제공하기 위해 사용한다.
> 예시 `Server: Tiki-Hut/1.0`

**4. 엔터티 헤더**
- 엔터티 본문에 대한 헤더를 말한다. 예를 들어, 본문 내 데이터 타입이 무엇인지 말해준다. 
> 예시 `Content-Type: text/html; charset=utf-8`

**5. 확장 헤더**
- 애플리케이션 개발자들에 의해 만들어졌지만, HTTP 명세에 추가되지 않은 비표준 헤더이다. 
HTTP 프로그램은 확장 헤더들에 대해 모를지라도 용인하여 전달해야 한다.

`캐시 헤더`는 `일반 헤더`의 한 종류로 원 서버로부터 객체를 가져오는 대신 **로컬 복사본으로 캐시할 수 있도록** 해준다. 
HTTP/1.0에서 최초로 도입되었다. 언제 어떻게 캐시가 되어야 하는지에 대한 **지시자를 제공**한다.

`엔터티 캐싱 헤더`는 엔터티 캐싱에 대한 정보를 제공한다. 예를 들면, 리소스에 대해 캐시된 사본이 아직 유효한지에 대한 정보, 
캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 추정하기 위한 단서가 된다.

엔터티 캐싱 헤더 중 하나인 `ETag`는 해당 엔터티에 대한 엔터티 태그로, 리소스의 특정 버전에 대한 **식별자**다.

## Reference
---
HTTP: The Definitive Guide