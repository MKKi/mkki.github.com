---
layout: post
title:  "[HTTP: The Definitive Guide] 12. 기본 인증"
date:   2018-02-09 11:17:02 +0900
background: '/img/posts/05.jpg'
categories: http
---

## 인증
---
웹을 통한 개인적인 업무 중, 모든 정보나 업무가 공용은 아니기에 `허가된 사람`만 데이터에 접근하고 업무를 처리할 수 있도록
`인증` 해야 한다.

HTTP는 `자체적인` 인증 관련 기능을 제공하고 있다. 하지만 요즘은 보안을 더 강화하기 위해 각각의 `인증 모듈`을 직접 구현한다.

#### HTTP의 인증요구/응답 프레임워크
HTTTP는 사용자 인증을 하는 데 사용하는 자체 `인증요구/응답 프레임워크`를 제공한다.

웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 **대신에** `인증요구`로 응답할 수 있다.

사용자가 다시 요청을 보낼 때는 `인증 정보`를 첨부해야 한다. 만약 이 정보가 맞지 않다면, 서버는 클라이언트에게
인증요구를 `재전송`하거나 `에러`를 낼 수 있다.

#### 인증 프로토콜과 헤더
HTTP는 필요에 따라 고쳐 쓸 수 있는 `제어 헤더`를 통해 다른 `인증 프로토콜`에 맞추어 확장할 수 있는 프레임워크를 제공한다.

인증 프로토콜은 HTTP 인증 헤더에 기술되며, 이에 따라 인증 프로토콜이 달라진다.

HTTP에는 `기본 인증`과 `다이제스트 인증`이라는 두 가지 공식적인 `인증 프로토콜`이 있다.
> 요즘에는 `OAuth` 인증 프로토콜을 사용한다. `OAuth`는 모바일 기기 같은 다양한 애플리케이션에서 `API` 인증을 위해
사용하는 최신 인증 프로토콜이다.

#### 보안 영역
서버가 클라이언트로 인증요구를 할 때, `realm` 지시자가 기술되어 있는 `WWW-Authenticate` 헤더가 있다.
이를 통해 HTTP는 각 리소스마다 다른 `접근 조건`을 다를 수 있다.

웹 서버는 기밀 문서를 `보안 영역(realm)` 그룹으로 나눈다. 보안 영역은 각기 다른 `사용자 권한`을 요구한다.
다음은 `realm` 파라미터가 함께 기술된 `기본 인증`의 예이다.
> HTTP1/1.0 401 Unauthorized
> WWW-Authenticate: Basic realm="Corpate Financials"

여기서 `realm`에 `example@company.com` 같은 `호스트 명`을 넣는 것도 유용할 수 있다.

## 기본 인증
---
기본 인증은 거의 모든 클라이언트와 서버에 구현되어 있다. 원래 `HTTP/1.0`에 기술되어 있었지만,
HTTP 인증의 상세 내용을 다루는 `RFC 2617`로 옮겨졌다. 기본 인증 다음과 같이 수행된다.

사용자가 특정 `리소스`를 요청한다. 그럼 서버는 `WWW-Autenticate` 헤더와 함께 해당 리소스에 접근하는데 필요한
비밀번호를 요구하는 `401 Authorization Required` 응답을 반환한다.

브라우저가 `401` 응답을 받고, 인증을 위한 `대화상자`를 띄운다. 사용자가 이름과 비밀번호를 입력하면,
브라우저는 그것들을 `콜론(:)`으로 이어 붙이고, `base-64` 방식으로 인코딩한다.

그리고 이를 `Authorization` 헤더에 값으로 담아 서버로 넘긴다. 서버가 사용자 이름과 비밀번호를 디코딩하고,
값에 문제가 없으면 `HTTP 200 OK` 메시지와 함께 요청받았던 문서를 보낸다.

`기본 인증 프로토콜`은 `Authentication-Info` 헤더를 사용하지 않는다.
> 특정 인증 알고리즘은 **선택적인** 헤더인 `Authentication-Info` 헤더에 인증 세션에 관한 추가 정보를 기술하여 응답한다.

#### Base-64 사용자 이름/비밀번호 인코딩
`base-64` 인코딩은 `8비트` 바이트로 이루어져 있는 시퀀스를 `6비트` 덩어리의 시퀀스로 변환한다.
각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 `64개`의 문자 중에서 선택된다.
> `base-64`로 인코딩된 문자열은 원래 값보다 `33%` 커진다.  

일련의 비트가 `6비트 조각`으로 고르게 나뉘지 않는다면, 그 길이를 `24비트`로 만들고 남은 비트는 `0`으로 채운다.  

만약 6비트 그룹이 모두 0이면 `=`으로 인코딩 된다. 그리고 일련의 비트 길이가 더 커지면 `24의 배수`로 길이가 늘어난다.

`base-64` 인코딩은 `바이너리`, `텍스트`, `국제 문자 데이터` 문자열을 받아서, 전송 가능한 문자인 `알파벳`으로
변환하기 위해 만들어졌다. 

따라서 HTTP 헤더에서 사용할 수 없는 `콜론(:)`, `캐리지 리턴(CRLF)`, `큰따옴표(")`를
포함한 사용자 정보를 보낼 때 유용하게 사용할 수 있다.

#### 프록시 인증
중개 프록시 서버를 통해 인증할 수도 있다. 프록시 서버에서 `접근 정책`을 `중앙 관리` 할 수 있기에,
서버 리소스 전체에 대해 `통합적인 접근 제어`를 수행할 수 있다.

이 절차의 첫 번째 단계는 `프록시 인증`으로 사용자를 식별하는 것이다. 
프록시 인증은 웹 서버의 인증과 `헤더`, `상태 코드`만 다르고 절차는 같다.
> 프록시 인증은 `407` 상태코드와 `Proxy-Authenticate`, `Proxy-Authentication`, `Proxy-Authentication-Info` 헤더를 가진다.

## 기본 인증의 보안 결함
---
기본 인증은 단순하고 편리하지만, 보안적 결함이 많아 잘 사용되지 않는다. 내용은 다음과 같다.

1. 기본 인증은 개인 정보를 **쉽게 디코딩**할 수 있는 형식으로 네트워크에 전송한다.
`base-64` 인코딩은 손으로도 디코딩할 수 있을 만큼 단순한 인코딩 알고리즘이다.

2. 보안 비밀번호가 더 복잡한 방식으로 인코딩되어 있다고 하더라도, `그 자체`를 서버로 보내 인증에 성공하여
서버에 접근할 수 있다. `기본 인증`은 이를 예방하기 위해 어떤 일도 하지 않는다.

3. 보안이 뚫리더라도 치명적이지 않은 애플리케이션에 `기본 인증`이 사용되더라도, 이 정보를 통해 `다른 웹 사이트`에
접근할 수 있다.

4. 메시지 `인증 헤더` 외의 `다른 부분`을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 `프록시`나
`중개자`가 개입한 경우에, `기본 인증`은 정상적인 동작을 보장하지 않는다.

5. `기본 인증`은 `가짜 서버`의 위장에 취약하다.

종합적으로 `기본 인증`은 노출되어도 문제 없는 정보에 사용하면 편리하다.

하지만 기밀 문서와 같은 **중요한 정보**에는 `암호화된 데이터 전송(SSL)`와 연결해서 사용해야 한다.

## Reference
---
HTTP: The Definitive Guide