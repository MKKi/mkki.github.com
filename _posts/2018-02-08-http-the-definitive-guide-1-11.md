---
layout: post
title:  "[HTTP: The Definitive Guide] 11. 클라이언트 식별과 쿠키"
date:   2018-02-08 12:24:12 +0900
background: '/img/posts/04.jpg'
categories: http
---

## 개별 접촉
---
HTTP는 `익명`을 사용하며 `상태`가 없고, 요청과 응답으로 통신하는 프로토콜이다.
> 연결 자체에 대한 정보를 가지지 않으며 매 요청은 `일회적`이고 `독립적`으로 처리된다.
이를 가리켜 HTTP는 `상태가 없다`고 하거나 `무상태(stateless)`라 부른다.

웹 서버는 요청을 보낸 사용자를 식벽하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 `약간의 정보`를 이용할 수 있다.

개별 인사
: 온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 `환영 메시지`나 `페이지 내용`을 만든다.

사용자 맞춤 추천
: 온라인 상점은 고객의 흥미가 무엇인지 `학습`해서 고객이 좋아할 것이라고 예상되는 상품을 추천한다.

저장된 개인 정보
: 온라인 쇼핑이 사용자를 한번 식별하고 나면, 쇼핑을 더 편하게 할 수 있도록 저장된 사용자 정보를 사용할 수 있다.

세션 추적
: `HTTP 트랜잭션`은 `상태`가 없다. 각 요청 및 응답은 독립적으로 일어난다. 많은 웹 사이트에서 사용자가 사이트와
상호작용할 수 있게 사용자의 상태를 남긴다.

이렇게 상태를 유지하려면, 웹 사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 `식별`할 방법이 필요하다.
다음은 이러한 식별 기술에 대한 내용이다.

## HTTP 헤더
---
`From` 헤더는 사용자의 `이메일 주소`를 포함한다. 이상적으로는 각 사용자가 다른 이메일 주소를 가지므로,
이를 통해 사용자를 식별할 수 있다.

하지만 악의적인 서버가 이메일 주소를 모아서 `스팸 메일`을 발송하는 문제가 있어서 `From` 헤더를 보내는
브라우저는 많지 않다.

`User-Agent` 헤더는 사용자가 쓰고 있는 브라우저의 `이름`과 `버전 정보`, 어떤 경우에는 `운영체제 정보`까지
포함하여 서버에게 알려준다. 

이는 `특정 브라우저`에서 제대로 동작하도록 그것들의 속성에 맞추어 컨텐츠를 `최적화`하는데 유용하다. 
하지만 특정 사용자를 `식별`하는 데는 큰 도움이 되지 않는다.

`Referer` 헤더는 사용자가 현재 페이지로 유입하게 한 웹페이지의 `URL`을 가리킨다. 이 자체로 사용자를 식별할 수는 없지만,
사용자의 `웹 사용 행태`나 `취향`을 파악할 수 있다.

다음은 사용자를 식별하는 보다 정확한 방법이다.

## 클라이언트 IP 주소
---
초기 웹에서는 클라이언트의 `IP 주소`를 통해 사용자를 식별하고자 했다.

사용자가 **확실한** IP 주소를 가지고 있고 그 주소는 좀처럼 바뀌지 않기에, 웹 서버가 매 요청에 클라이언트 IP를 알 수 있다면
문제없이 동작할 것이다.

클라이언트의 IP 주소는 보통 HTTP 헤더에 없지만, 웹 서버는 HTTP 요청을 보내는 반대쪽 `TCP 커넥션`의 IP 주소를 알아낼 수 있다.
> 유닉스 시스템에서 getpeername 함수를 호출하면, 요청을 보낸 클라이언트의 IP 주소를 알 수 있다

그러나 클라이언트 IP 주소로 사용자를 식별하는 방법은 다음과 같은 단점이 존재한다.
- 클라이언트 IP 주소는 사용자가 아닌, 사용하는 `컴퓨터`를 가리킨다. 만약 여러 사용자가 `같은 컴퓨터`를 사용한다면
그들을 식별할 수 없을 것이다.

- 많은 `인터넷 서비스 공급자(ISP)`는 사용자가 로그인하면 `동적`으로 IP 주소를 할당한다. 로그인한 `시간`에 따라
매번 다른 주소를 할당하므로, 웹 서버는 사용자를 식별할 수 없다.

- `네트워크 주소 변환(Network Address Translation, NAT)` 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고,
이를 내부에서 사용하는 하나의 `방화벽 주소(그리고 포트번호)`로 변환한다.
> 인터넷 사용 시, 보안을 강화하고 부족한 주소를 관리하기 위해 `NAT 방화벽`을 사용한다

- 보통 `HTTP 프록시`와 `게이트웨이`는 원 서버에 새로운 `TCP 커넥션`을 생성한다. 웹 서버는 클라이언트의 IP 주소
대신에 중개자의 IP 주소를 본다. 일부 프록시는 원본 IP 주소를 보존하려고 `Client-ip`나 `X-Forwarded-For-HTTP` 같은
`확장 헤더`를 사용하지만, 모든 프록시가 이와 같이 동작하진 않는다.

## 사용자 로그인
---
웹 서버는 사용자에게 `사용자 이름`과 `비밀번호`로 인증할 것을 요구하여 `명시적`으로 식별 요청을 할 수 있다.

HTTP는 웹 사이트 로그인이 더 쉽도록 `WWW-Authenticate`와 `Authentication` 헤더를 사용하여 웹 사이트로 `사용자 이름`을
전달하는 자체적인 체계를 가지고 있다.

한번 로그인하면, 브라우저는 사이트로 보내는 `모든 요청`에 이 로그인 정보를 함께 보내므로 웹 서버는 해당 정보를
항상 확인할 수 있다.

사용자가 사이트에 접근하면 서버는 `401 Login Required` 응답 코드를 브라우저에 보낼 수 있다. 브라우저는 로그인
대화상자를 보여주고, 다음 요청부터 `Authentication` 헤더에 그 정보를 기술하여 보낸다.
> 대부분의 브라우저는 **로그인 정보를 기억**하여 매 요청마다 사용자가 로그인하지 않도록 해준다.
또한, `Authentication` 헤더는 암호화되어 네트워크 상에서 관찰자가 보지 못하게 보호한다.

## 뚱뚱한 URL
---
어떤 웹 사이트에서는 `사용자의 URL`마다 버전을 기술하여 사용자를 식별하고 추적하였다.
보통 URL은 경로의 처음이나 끝에 `상태 정보`를 추가해 확장한다.

사용자가 그 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 `하이퍼링크`를 동적으로 생성한다.
이러한 URL을 `뚱뚱한 URL(fat URL)`이라고 부른다.

웹 서버와 통신하는 `독립적인` HTTP 트랜잭션을 하나의 `세션` 혹은 `방문`으로 묶는 용도로 뚱뚱한 URL을 사용할 수 있다.
이는 사이트를 `브라우징`하는 사용자를 식별할 수 있지만, 다음과 같은 심각한 문제들이 있다.

- 브라우저에 보이는 뚱뚱한 URL은 `새로운 사용자`들에게 혼란을 준다.
- 뚱뚱한 URL은 `특정 사용자`와 `세션 정보`를 포함한다. 따라서 타인과 공유할 수 없다.
- URL이 달라지기에 `기본 캐시`에 접근할 수 없다. 결국 캐시를 사용할 수 없게 된다.
- 서버는 뚱뚱한 URL에 해당하는 `HTML 페이지`를 다시 그려야하기에 `부하`가 가중 된다.
- 사용자가 다른 사이트로 이동하거나 `특정 URL`을 요청하여 뚱뚱한 URL `세션`에서 `이탈`하기 쉽다.
이로 인해 그동안 쌓아온 상태 정보가 `초기화` 된다.
- 사용자가 특정 뚱뚱한 URL을 `북마킹`하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.
즉 세션 간 `지속성`이 없다.

## 쿠키
---
쿠키는 사용자를 `식별`하고 `세션`을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.

쿠키는 앞선 기술들이 가지고 있던 문제들이 발생하진 않지만, 쿠키 **자체만으로** 하기 어려운 일은
앞선 기술들을 함께 사용하기도 한다.

쿠키는 `새로운 HTTP 헤더`를 정의한다. 또한 `캐시`와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는
내용물을 **캐싱하지 않는다.**

쿠키의 타입
: 쿠키는 크게 `세션 쿠기(session cookie)`와 `지속 쿠키(persistent cookie)` 두 가지 타입으로 나눌 수 있다.

: `세션 쿠키`는 사용자가 사이트를 탐색할 때, `관련된 설정`과 `선호 사항`들을 저장하는 `임시 쿠키`이다.

: `지속 쿠키`는 디스크 안에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 삭제되지 않고 남아있다.
사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.

: 둘의 차이점은 `파기되는 시점`뿐이다. 쿠키는 `Discard` 파라미터가 설정되어 있거나, 파기되기까지 남은
시간을 가리키는 `Expires`, `Max-Age` 파라미터가 없으면 `세션 쿠키`가 된다.

쿠키는 어떻게 동작하는가
: 쿠키는 서버가 사용자에게 붙이는 `스티커`와 같다. 사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게
붙인 모든 스티커를 읽을 수 있다.

: 처음 사용자가 웹 사이트에 방문하면 웹 서버는 사용자를 식별하고자 `유일한 값`인 쿠키를 할당한다.
쿠키는 `임의의 이름=값` 형태의 리스트를 가지며, 이는 `Set-Cookie`, `Set-Cookie2(확장 헤더)` 같은 HTTP 응답 헤더에
기술되어 사용자에게 전달된다.

: 쿠키는 `어떤 정보`든 포함할 수 있지만, 서버가 사용자 추적 용도로 생성한 유일한 `단순 식별 번호`만 포함하기도 한다.

: 브라우저는 서버로부터 온 `Set-Cookie`나 `Set-Cookie2` 헤더에 있는 `쿠키 컨텐츠`를 브라우저 `쿠키 데이터베이스`에
저장한다. 나중에 사용자가 재방문하면, 브라우저는 쿠키를 `Cookie` 요청 헤더에 기술해 전송한다.

쿠키 상자: 클라이언트 측 상태
: 쿠키의 `기본적인 발상`은 브라우저가 `서버 관련 정보`를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 `정보`를
**함께 전송**하게 하는 것이다.

브라우저는 쿠키 정보를 저장할 `책임`이 있는데, 이 시스템을 `클라이언트 측 상태`라고 한다. 쿠키 명세에서의
공식적인 이름은 `HTTP 상태 관리 체계(HTTP State Management Mechanism)`이다.

각 브라우저는 각기 다른 방식으로 쿠키를 저장한다. `구글 크롬`은 `Cookie`라는 `SQLite` 파일을 쿠키에 저장한다.

사이트마다 각기 다른 쿠키들
: 브라우저는 수천 개의 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 쿠키 `전부`를 모든 사이트에 보내진 않는다.
사실 브라우저는 각 사이트에 `2-3개의 쿠키`만을 보낸다. 이유는 다음과 같다.

- 쿠키를 모두 전달하면 실제 컨텐츠 바이트보다 **더 많은** `쿠키 바이트`를 전달하게 되는 것이므로 `성능`이 크게 저하된다.
- 대부분의 쿠키는 서버에 특화된 `이름/값 쌍`을 포함하고 있기에, 사이트에서는 무의미한 값일 수 이다.
- 쿠키 전체를 전달하는 것은 `개인정보 문제`를 야기할 수 있다.
특정 사이트에 제공한 정보를 `신뢰하지 않는 사이트`에서 가져갈 수 있기 때문이다.

보통 브라우저는 `쿠키를 생성한` 서버에게만 쿠키에 담긴 `정보`를 전달한다. 

많은 웹사이트는 광고 업체와 계약을 한다. 광고들은 웹 사이트의 `일부`인 것처럼 제작되고, `지속 쿠키`를 만들어낸다.
이를 `Referer` 헤더와 접목시켜 사용자의 웹 서핑 습관에 대한 `데이터`를 구축할 수 있게 된다.

최신 브라우저들은 `개인정보 설정` 기능을 통해 이러한 쿠키 사용 방식을 제약할 수 있도록 해준다.
- `Set-Cookie` 응답 헤더에 `Domain` 속성을 기술해서 `어떤 사이트`가 그 쿠키를 읽을 수 있을지 제어할 수 있다.
- URL 경로의 앞부분을 가리키는 `Path` 속성을 기술해서 `해당 경로`에 속하는 페이지에만 쿠키를 전달할 수 있다.

쿠키 구성요소
: 현재 사용되는 `쿠키 명세`에는 `Version 0 쿠키(넷스케이프 쿠키)`가 있다.
> `Version 1 쿠키`는 폐기되어 사용되지 않는 `HISTORIC` 상태이다.

Version 0 쿠키(넷스케이프 쿠키)
: 최초의 `쿠키 명세`는 `넷스케이프`가 정의했다. `Version 0 쿠키`는 `Set-Cookie` 응답 헤더와 `Cookie` 요청 헤더,
그리고 쿠키를 조작하는데 필요한 필드를 정의하였다. 형태는 다음과 같다.
> Set-Cookie: name=value \[; expires=date] \[; path=path] \[; domain=domain] \[; secure]  
> Cookie: name1=value1 \[; name2=value2]

Set-Cookie 헤더
: `Set-Cookie` 헤더는 쿠키의 이름과 값을 가져야 한다. 

Cookie 헤더
: 클라이언트가 서버에 요청을 보낼 때는, `Domain`, `Path`, `Secure` 필터들이 현재 요청하려고 하는 사이트에 들어맞으면서
아직 파괴되지 않은 쿠키들을 함께 보낸다. 모든 쿠키는 `Cookie` 헤더에 이어 붙여 보낸다.

쿠키와 세션 추적
: 쿠키는 웹 사이트에 수차례 `트랜잭션`을 만드러내는 사용자를 추적하는 데 사용한다.

: 예로 특정 웹 사이트에 접속하면, 일련의 `리다이렉트`와 `URL 리라이트`, `쿠키 설정`을 통해 서버가 식별 정보를 첨부하기
위한 연속적인 트랜잭션을 시작한다.

쿠키와 캐싱
: 쿠키 트랜잭션과 관련된 문서를 `캐싱`하는 것은 주의해야 한다. 쿠키가 다른 사용자에게 할당돼버리거나,
누군가의 개인 정보가 다른 이에게 노출될 수도 있다. 다음은 캐시를 다루는 기본 원칙들이다.

- 캐시되지 말아야 할 문서가 있다면, 그 문서에 명시적으로 `Cache-Control: no-cache="Set-Cookie"`를 기술해야 한다.
반대의 경우에는 `Cache-Control: public`을 사용하면 웹의 `대역폭`을 더 절약시켜준다.

- `Set-Cookie` 헤더를 캐시 하는 것에 유의해야한다. 같은 `Set-Cookie` 헤더를 여러 사용자에게 보내면 `사용자 추적`에 실패할 것이다.
또한, 어떤 캐시는 응답을 저장하기 전에 `Set-Cookie` 헤더를 제거하기에, 클라이언트는 해당 헤더 정보가 없는 데이터를 받게 된다.

- 요청에 `Cookie` 헤더가 있다면, 결과 컨텐츠가 `개인정보`를 담고 있을 수도 있다. 개인정보는 **캐시되지 않도록** 해야하지만,
그렇지 하지 않는 서버도 있다. `보수적인 캐시`는 `Cookie` 헤더가 포함된 요청에 대한 응답으로 오는 문서는 **캐시하지 않는다.**

- 더 효율적인 방식은 캐시된 이미지에 `파기 시간`이 0인 `Cookie` 헤더를 설정해서 매번 `재검사`를 하도록 강제하는 것이다.

쿠키, 보안 그리고 개인정보
: 쿠키를 사용하지 않도록 `비활성화`시킬 수 있고 `로그 분석` 같은 다른 방법으로 대체하는 것도 가능하므로,
그 자체가 `보안`상으로 엄청나게 위험한 것은 아니다.

: `원격 데이터베이스`에 개인정보를 저장하고 해당 데이터의 `키 값`을 쿠키에 저장하는 방식을 `표준`으로 사용하면,
클라이언트와 서버 사이에 `예민한 정보`가 오가는 것을 줄일 수 있다.

: `광고 업체`의 예시처럼, 쿠키의 잘못된 오용만 줄인다면 쿠키의 위험성보다 `세션 조작`과 `트랜잭션` 상의 편리함이 더 크다.

## Reference
---
HTTP: The Definitive Guide