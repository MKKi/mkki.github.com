---
layout: post
title:  "[HTTP: The Definitive Guide] 7. 캐시"
date:   2018-02-01 15:21:01 +0900
background: '/img/posts/06.jpg'
categories: http
---

## 불필요한 데이터 전송
---
복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 `같은 문서`를 클라이언트들에게 각각 한 번씩 전송하게 된다.

똑같은 바이트들이 네트워크를 통해 계속 **반복해서 이동**한다. 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고,
전송을 느리게 만들며, 웹 서버에 부하를 준다.

`캐시`를 이용하면, 첫 번째로 서버 응답은 캐시에 보관된다. `캐시된 사본`이 뒤이은 요청들에 대한 응답으로 사용될 수 있기에,
원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다.

## 대역폭 병목
---
캐시는 또한 `네트워크 병목`을 줄여준다. 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.

클라이언트들이 서버에 접근할 때 속도는, 그 경로에 `가장 느린 네트워크`의 속도와 같다. 
만약 클라이언트가 빠른 `LAN`에 있는 캐시로부터 사본을 가져온다면, `캐싱`은 성능을 대폭 개선할 수 있을 것이다.

`대역폭`은 큰 문에서 대해 큰 지연을 일으키며, `속도`는 네트워크 종류에 따라 달라진다.
> `전송 속도`란, 초당 전송되는 현재의 비트의 평균 속도를 나타낸다.
> `대역폭`이란, 초당 전송될 수 있는 최대량을 의미한다.

## 갑작스러운 요청 쇄도(Flash Crowds)
---
캐싱은 `갑작스러운 요청 쇄도`에 대처하기 위해 중요하다. 갑작스런 사건으로 많은 사람이 동시에 웹 문서에 접근할 때
이런 일이 발생한다. 이 결과로 초래된 불필요한 `트래픽 급증`은 네트워크와 웹 서버의 심각한 장애를 야기시킨다.

## 거리로 인한 지연
---
대역폭이 문제가 되지 않더라도, **거리**가 문제가 될 수 있다. 모든 `네트워크 라우터`는 제각각 인터넷 트래픽을 지연시킨다.
그리고 클라이언트와 서버 사이에 라우터가 그다지 많지 않더라도, `빛의 속도` 그 자체가 유의미한 지연을 유발한다.

기계실 근처에 `캐시`를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

## 적중과 부적중
---
캐시는 **모든 문서의 사본**을 저장하지 않는다. 캐시에 요청이 도착했을 때 사본이 존재한다면, 그를 이용해 요청이 처리될 수 있다.
이것을 `캐시 적중(cache hit)`이라고 한다.

만약 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐이다. 이것을 `캐시 부적중(cache miss)`이라고 한다.

재검사(Revalidation)
: 원 서버 컨텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 **여전히 최신인지** 서버를 통해 점검해야 한다.
이러한 신선도 검사를 `HTTP 재검사`라고 한다.

: 효과적인 재검사를 위해 HTTP는 서버로부터 **전체 객체**를 가져오지 않고 컨텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한
요청을 정의했다.

: 캐시는 스스로 원한다면 **언제든지** 사본을 `재검사`할 수 있다. 

: 캐시가 문서를 수백만 개씩 갖고 있는 경우에 비해 `네트워크 대역폭`은 부족하기에, 
대부분의 캐시는 클라이언트가 사본을 요청하였으며 검사가 필요할 정도로 **충분히 오래된 경우**에만 재검사를 한다.

: 캐시는 재검사가 필요할 때, 원 서버에 작은 `재검사 요청`을 보낸다. 컨텐츠가 변경되지 않았다면, 서버는 아주 작은 `304 Not Modified`
응답을 보낸다. 사본이 유효함을 알게 된 캐시는 **임시로 표기**를 한 뒤 사본을 클라이언트에게 제공한다.

: 이를 `재검사 적중(느린 적중)`이라고 부른다. 이것은 `순수 캐시 적중`보다 느린데, 원 서버와 검사를 할 필요가 있기 때문이다.
그러나 `캐시 부적중`보다는 빠른데, 서버로부터 객체 데이터를 받아올 필요가 없기 때문이다.

: HTTP는 캐시된 객체를 재확인하기 위해 몇 가지 도구를 제공한다. 그 중 가장 많이 사용되는 것은 `If-Modified-Since 헤더`이다.
서버에게 보내는 `GET` 요청에 이 헤더를 추가하면, **캐시된 시간 이후 변경된 경우**에만 사본을 보내달라는 의미이다.

: 다음은 `GET If-Modified-Since` 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황이다.
1. 재검사 적중
    - 만약 서버 객체가 **변경되지 않았다면**, 서버는 클라이언트에게 작은 `HTTP 304 Not Modified` 응답을 보낸다.
2. 재검사 부적중
    - 만약 서버 객체가 **캐시된 사본과 다르다면**, 서버는 컨텐츠 전체와 함께 평범한 `HTTP 200 OK` 응답을 보낸다.
3. 객체 삭제
    - 만약 서버 객체가 **삭제 되었다면**, 서버는 `404 Not Found` 응답을 돌려보내며, 캐시는 사본을 삭제한다.
    
    
적중률
: 캐시가 요청을 처리하는 비율을 `캐시 적중률(문서 적중률)`이라고 부른다. 적중률은 `0에서 1까지의 값`으로 되어 있지만,
흔히 `퍼센트(%)`로 표현되기도 한다.

: 캐시 관리자는 캐시 적중률이 `100%`에 근접하게 되는 것을 좋아할 것이다. 보통 크기의 캐시라도 **충분한 분량**의 자주 쓰이는
문서를 보관하여, `트래픽`을 줄이고 `성능`을 개선할 수 있다.

: 캐시는 유용한 컨텐츠가 캐시 안에 머무르도록 보장하기 위해 노력한다.

바이트 적중률
: 문서들이 모두 같은 크기가 아니기에 `문서 적중률`이 모든 것을 말해주지는 않는다.
몇몇 큰 객체는 덜 접근되지만, 그 크기 때문에 전체 트래픽에는 더 크게 기여한다.
이러한 이유로 어떤 사람들은 `바이트 단위 적중률` 측정 값을 더 선호한다.

: 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 바이트 단위 적중률 `100%`는 모든 바이트가
캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다.

: `문서 적중률`은 얼마나 많은 웹 트랜잭션을 `외부로` 내보내지 않았는지 보여준다. 또한, 이를 개선하면 트랜잭션의
전체 `대기시간(지연)`을 줄일 수 있다.

: `바이트 단위 적중률`은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지를 보여준다. 이를 개선하면 대역폭을 절약할 수 있다.

적중과 부적중의 구별
: HTTP는 클라이언트에게 응답이 **캐시 적중이었는지, 아니면 원 서버 접근인지** 말해줄 수 있는 방법을 제공하지 않는다.
두 경우 모두 응답 코드는 모두 본문을 갖고 있음을 의미하는 `200 OK`가 될 것이다.

: 어떤 `상용 프록시 캐시`는 캐시에 무슨 일이 일어났늦지 설명하기 위해 `Via 헤더`에 추가 정보를 붙인다.

: 클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은, `Date 헤더`를 이용하는 것이다. 응답의 `Date 헤더` 값을
현재 시각과 비교하여, **응답의 생성일이 더 오래되었다면** 클라이언트는 캐시된 것임을 알아낼 수 있다.

: 또 다른 방법은, 응답이 얼마나 오래되었는지 말해주는 `Age 헤더`를 이용하는 것이다.

## 캐시 토폴로지
---
캐시는 **한 명의 사용자**에게만 할당될 수도 있고, 반대로 **수 천명의 사용자들**에게 공유될 수 있다.

개인 전용 캐시
: `개인 전용 캐시`는 한 명에게만 할당된 캐시다. 한 명의 사용자를 대상으로 하기에, **많은 에너지나 저장 공간**을
필요로 하지 않는다. 웹 브라우저는 개인 전용 캐시를 **내장**하고 있다.
 
: 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 `디스크`와 `메모리`에 캐시해 놓고, 
사용자가 `캐시 사이즈`와 `설정`을 수정할 수 있도록 허용한다. 캐시에 어떤 것들이 들어있는지 확인하기 위해
브라우저 안을 들여다보는 것도 가능하다.

공용 프록시 캐시
: `공용 캐시`는 `캐시 프록시 서버(프록시 캐시)`라고 불리는 특별한 종류의 공유된 프록시 서버이다.
프록시 캐시는 `로컬 캐시`에서 문서를 제공하거나, 혹은 `사용자 입장`에서 서버에 접근한다.
공용 캐시에는 **여러 사용자**가 접근하기에, `불필요한 트래픽`을 줄일 수 있다.

프록시 캐시 계층들
: 작은 캐시에서 `캐시 부적중`이 발생했을 때, 
더 큰 부모 캐시가 `남겨진 트래픽`을 처리하도록 계층을 만드는 방식이 합리적인 경우가 많다.

: 이 아이디어는 클라이언트 주위에는 `작고 저렴한 캐시`를 사용하고, 계층 상당에는 많은 사용자들에게
공유되는 문서를 유지하고자 `더 크고 강력한 캐시`를 사용하자는 것이다.
> `부모 캐시`는 `자식 캐시`들의 모든 트래픽을 감당해야하므로, 고성능이어야 한다.

: 프록시 연쇄가 길어질수록, 각 중간 프록시는 현저한 `성능 저하`가 발생할 것이다.
> 실제로 네트워크 아키텍트들은 2~3개의 프록시만 거치도록 스스로 제한한다.

캐시망, 컨텐츠 라우팅, 피어링
: 몇몇 `네트워크 아키텍처`는 단순한 캐시 계층 대신 `복잡한 캐시망`을 만든다. 캐시망의 프록시 캐시는 복잡한 방법으로
서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에
대한 `캐시 커뮤니케이션 결정`을 **동적**으로 내린다.

: 캐시망 안에서 `컨텐츠 라우팅`을 위해 설계된 캐시들은 다음에 나열된 일을 할 수 있다.
    - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
    - URL에 근거하여, 특정 부모 캐시를 **동적**으로 선택한다.
    - 부모 캐시에게 가기 전에, **캐시된 사본**을 로컬에서 찾아본다.
    - 다른 캐시들이 그들의 캐시된 컨텐츠에 부분적으로 접근할 수 있도록 허용한다.
    하지만 캐시를 통한 `인터넷 트랜짓(Internet Transit)`은 허용하지 않는다.
    > `인터넷 트랜짓(Internet Transit)`이란 트래픽이 다른 네트워크로 건너가는 것이다.

: 이러한 캐시 관계는 서로 다른 조직들이 `상호 이익`을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해준다.
`선택적인 피어링`을 지원하는 캐시는 `형제 캐시`라고 불린다.

: HTTP는 형제 캐시를 지원하지 않기에, 사람들은 `인터넷 캐시 프로토콜(ICP)`이나 `하이퍼텍스트 캐시 프로토콜(HTCP)`
같은 프로토콜을 이용해 HTTP를 **확장**했다.

## 캐시 처리 단계
---
오늘날 `상용 프록시 캐시`는 꽤 복잡하다. **고성능**이면서도 HTTP와 그 외 다른 기술의 **고급 기능을 지원**하도록 만들어졌다.

몇 군데 미묘한 구석이 있긴 하지만, 웹 캐시의 기본적인 동작은 대개 **단순하다.** 다음은 요청 메시지 하나를 처리하는
기본적인 캐시 처리 절차이다.

1. 요청 받기
: 캐시는 `네트워크 커넥션`의 활동을 감지하고, 들어오는 데이터를 읽어들인다.
`고성능 캐시`는 여러 개의 들어오는 커넥션들로부터 **데이터를 동시에 읽어**들이고 메시지 전체가 도착하기 전에
트랜잭션 처리를 시작한다.

2. 파싱
: 다음으로 캐시는 요청 메시지를 여러 부분으로 `파싱`하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.
이는 `캐싱 소프트웨어`가 헤더 필드를 처리하고 조작하기 쉽게 만들어준다.
> 파서는 헤더 부분에 대해 대소문자나 날짜 형식의 차이와 같이 `중요하지 않는 차이점`이 모두 무시되도록
> 정규화할 책임을 갖고 있다. 또한, 요청 메시지가 `절대 URL`을 갖고 있는지, `상대 URL`과 `Host 헤더`를 갖고 있는지에
대한 차이점을 숨긴다.

3. 검색
: 캐시는 URL을 알아내고 그에 해당하는 `로컬 사본`이 있는지 검사한다. 로컬 사본은 `메모리`에 저장되어 있을 수도 있고,
`디스크`나 `다른 컴퓨터`에 있을 수도 있다.
: 전문적인 수준의 캐시는 `객체`를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용한다.
만약 문서를 로컬에서 가져올 수 없다면, 캐시는 설정에 따라 그것을 `원 서버`나 `부모 프록시`에서 가져오거나 실패를 반환한다.
: `캐시된 객체`는 서버 `응답 본문`과 원 서버 `응답 헤더`를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있다.
또한, 객체가 **얼마나 오랫동안** 캐시에 머무리고 있었는지를 알려주는 기록이나, 
**얼마나 자주 사용**되었는지에 대한 `메타 데이터`를 포함한다.

4. 신선도 검사
: HTTP는 캐시가 **일정 기간 동안** 서버 문서의 `사본`을 보유할 수 있도록 해준다.
이 기간 동안, 문서는 `신선`한 것으로 간주되고 캐시는 서버와의 접촉 없이 이 문서를 제공할 수 있다.
: 그러나 일단 캐시된 사본을 신선도 한계를 넘을 정도로 오래 갖고 있었다면, 그 객체는 `신선하지 않은`것으로 간주되며
캐시는 해당 문서를 제공하기 전에 서버와 `재검사`를 해야한다.

5. 응답 생성
: 우리는 `캐시된 응답`을 원 서버에서 온 것처럼 보이게 하고 싶기 때문에, 캐시는 `캐시된 서버 응답 헤더`를 토대로
응답 헤더를 생성한다. 이 `기저 헤더`들은 캐시에 의해 수정되고 늘어난다.
: 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있다. 또한, `캐시 신선도 정보(Cache-Control, Age, Expires 헤더)`
를 삽입하며, 요청이 프록시 캐시를 거쳐갔음을 알려주기 위해 `Via 헤더`를 포함시킨다.
: 캐시는 `Date 헤더`를 조정해서는 안 된다. 이는 그 객체가 원 서버에서 **최초로** 생겨난 일시를 표현하는 것이다.

6. 전송
: `응답 헤더가` 준비되면, 캐시는 응답을 클라이언트에게 돌려준다. 모든 프록시 서버들과 마찬가지로, 프록시 캐시는
클라이언트와의 커넥션을 유지할 필요가 있다. 고성능의 캐시는 `로컬 저장장치`와 `네트워크 I/O 버퍼` 사이에서
문서의 컨텐츠 복사를 피함으로써 데이터를 효과적으로 전송한다.

7. 로깅
: 대부분의 캐시는 `로그 파일`과 `캐시 사용`에 대한 통계를 유지한다. 각 캐시 트랜잭션이 완료된 후,
캐시는 `통계 캐시 적중`과 `부적중` 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, 
URI 그리고 무엇이 일어났는지 알려주는 항목을 추가한다.
: 가장 많이 쓰이는 캐시 로그 포맷은 `스퀴드 로그 포맷(Squid Log Format)`이다.

## 사본을 신선하게 유지하기
---
캐시된 사본이 **항상** 서버의 문서와 일치하는 것은 아니다. 따라서 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.

HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지시켜주는
메커니즘을 `문서 만료`와 `재검사`라고 한다.

문서 만료
: HTTP는 `Cache-Control`과 `Expires`라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 **유효기간**을 붙일 수 있게 해준다.
이 헤더들은 `컨텐츠`가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우한다.
: 캐시 문서가 만료되기 전에, 캐시가 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있다. 그러나 만료되면, 캐시는
**반드시** 서버와 문서에 변경된 것이 있는지 검사해야 한다.

유효기간과 나이
: 서버는 응답 본문과 함께 하는, `HTTP/1.0+ Expires`나 `HTTP/1.1 Cache-Control: max-age` 응답 헤더를 이용해서
유효기간을 명시한다.
: 이 둘은 기본적으로 같은 일을 하지만, `Expires`는 절대 시간이기에 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구한다.
> `Cache-Control: max-age` 값은 문서의 최대 나이를 정의한다. 단위는 `초(s)`이다.

서버 재검사
: 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 존재하는 것과 **다르다는 것**을 의미하는 것이 아니다.
단지 이제 **검사할 시간**이 되었음을 뜻한다. 

: 캐시가 원 서버에서 문서가 변경되었는지의 여부를 물어보는 것을 `서버 재검사`라고 한다.
    - 재검사 결과 컨첸츠가 변경되었으면, 캐시는 그 문서의 `새로운 사본`을 가져와 캐시에 저장한 후
    클라이언트에게 이를 전송한다.
    - 재검사 결과 컨텐츠가 변경되지 않았다면, 캐시는 `새 만료일`을 포함한 새 헤더들만 가져와서
    캐시 안의 헤더들을 **갱신한다.**
    
: 캐시는 문서의 신선도를 매 요청마다 검증할 필요 없이, **문서가 만료**되었을 때 한 번만 서버와 재검사하면 된다.
이는 통해 `서버 트래픽`을 절약하고 `사용자 응답 시간`을 개선할 수 있으며, 동시에 신선한 컨텐츠를 제공할 수 있게 된다.

: HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 행동을 할 것을 요구한다.
    - `충분히 신선한` 캐시된 사본
    - 원 서버와 `재검사`되었기에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
    - 재검사해야 하는 원 서버가 다운된 경우, 통신 실패 에러 메시지
    - 캐시의 사본이 부정확하다면 경고 메시지를 사본에 부착

조건부 메서드와의 재검사
: `HTTP 조건부 메서드`는 재검사를 효율적으로 만들어준다. HTTP는 캐시가 서버에게 `조건부 GET`이라는 요청을 보낼 수 있도록 해준다.
이는 서버가 갖고 있는 문서가 캐시의 것과 **다른 경우**에만 `객체 본문`을 보내달라고 하는 것이다.

: 이런 방법으로, 신선도 검사와 객체를 받아오는 것은 하나의 조건부 GET으로 결합된다.
조건부 GET은 `GET` 요청 메시지에 특별한 `조건부 헤더`를 추가함으로써 시작된다. 웹 서버는 조건이 **참인 경우에만** 객체를 반환한다.

: HTTP는 다섯 가지 조건부 헤더를 정의한다. 그 중 둘은 `캐시 재검사`를 할 때 가장 유용한
`If-Modified-Since`와 `If-None-Match`이다. 모든 조건부 헤더는 `'If-'`접두어로 시작한다. 

If-Modified-Since: 날짜 재검사
: 가장 흔히 쓰이는 캐시 재검사 헤더는 `If-Modified-Since`이다. 이는 흔히 `IMS` 요청으로 불리며,
서버에게 리소스가 `특정 날짜 이후`로 변경된 경우에만 요청한 본문을 보내달라고 한다.
    - 만약 문서가 주어진 날짜 이후에 변경되었다면, `If-Modified-Since` 조건은 **참**이고, 따라서 `GET 요청`은 평범하게 성공한다.
    - 만약 문서가 주어진 날짜 이후에 변경되지 않았다면, 조건은 **거짓**이고 서버는 `304 Not Modified` 응답 메시지를
    클라이언트에게 돌려준다. 여기에서 응답은 `헤더`들은 포함하지만 **갱신**이 필요한 것만 보내고, `본문`은 보내지 않는다.
: `If-Modified-Since` 헤더는 서버 응답 헤더의 `Last-Modified` 헤더와 함께 동작한다. 원 서버는 제공하는 문서에
최근 변경 일시를 붙인다. 캐시가 문서를 재검사 하려고 할 때, 캐시된 사본이 **마지막으로 수정된 날짜**가 담긴 
`If-Modified-Since` 헤더를 포함한다.
: 몇몇 웹 서버는 `If-Modified-Since`를 실제 날짜 비교로 구현하지 않는다. 대신 그들은 `IMS 날짜`와 최근 변경일 간의 
**문자열 비교**를 수행한다. 즉 `이 날짜 이후로 변경되었다면`이 아니라 `정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면`
이라는 의미로 동작한다.
: 예를 들어 일련번호 같은 것을 최근 변경 일시로 사용한다면, 클라이언트는 `If-Modified-Since` 헤더를 시간에 대한 값으로서는
활용할 수 없겠지만, `캐시 만료`와 관련된 동작에는 문제가 없다.

If-None-Match: 엔터티 태그 재검사
: 다음과 같이 `최근 변경 일시 재검사`가 행해지기 어려운 상황이 있다.
    - 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만, 실제로는 `같은 데이터`를 포함하고 있다. 내용에는 변화가 없더라도
    `변경시각`은 바뀔 수 있다.
    - 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수도 있다.
    > 철자나 주석의 변경과 같은 경우
    - 어떤 서버들은 그들이 갖고 있는 페이지에 대한 `최근 변경 일시`를 **정확하게** 판별 할 수 없다.
    - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게, 변경일에 대한 `1초의 정밀도`는 충분하지 않을 수 있다.
    > Cahe-Control: max-age 헤더의 값은 `초(s)` 단위이다.
: `Last-Modified` 헤더보다 강력한 유효성 검사자가 있다. 바로 `엔터티 태그(ETag)`이다. 
아래는 엔터티 태그가 `v2.6`인 문서의 `If-None-Match` 조건부 헤더의 예시이다. 만약 엔터티 태그가 바뀌지 않았다면,
서버는 `304 Not Modified`로 응답할 것이다.

~~~
    If-None-Match: "v2.6"
~~~

캐시가 객체에 대한 `여러 개의 사본`을 갖고 있는 경우, 그 사실을 서버에게 알리기 위해 하나의 `If-None-Match` 헤더에
여러 개의 엔터티 태그를 포함시킬 수 있다.
~~~
    If-None-Match: "v2.4","v2.5","v2.6"
~~~

약한 검사기와 강한 검사기
: 캐시는 `캐시된 버전`이 서버의 것에 비해 최신인지 확인하고자 `엔터티 태그(ETag)`를 사용한다.
이 경우, 엔터티 태그와 최근 변경일시는 둘다 `캐시 검사기`다.
: 서버는 때때로 모든 `캐시된 사본`을 무효화시키지 않고, 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있다.
HTTP/1.1은 비록 컨텐츠가 조금 변경되었더라도 `그 정도면 같은 것`이라고 서버가 주장할 수 있도록 해주는
`약한 검사기(week validator)`를 지원한다.
: `강한 검사기(strong validator)`는 컨텐츠가 바뀔 때마다 바뀐다. 약한 검사기는 어느 정도 컨텐츠의 변경을 허용하지만,
컨텐츠의 중요한 의미가 변경되면 함께 변견된다.

: `조건부 특정범위 가져오기` 같은 몇몇 동작은 `약한 검사기`로는 불가능하기 때문에 서버는 `W/` 접두사로 약한 검사기를
구분한다.
~~~
    Etag: W/"v2.6"
    If-None-Math: W/"v2.6"
~~~

강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 **반드시** 같이 바뀌어야 한다.

원 서버는 서로 다른 두 엔터티에 대해 강한 엔터티 태그 값을 `재활용`해서는 안되며, 약한 엔터티 태그 값이라고 할지라도
**서로 의미가 다른** 두 엔터티에 대해서는 재활용해서는 안된다.

언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
: HTTP/1.1 클라이언트는 만약 서버가 `엔터티 태그`를 반환했다면, 반드시 `엔터티 태그 검사기`를 사용해야 한다.
만약 서버가 `Last-Modified` 값만을 반환했다면, 클라이언트는 `If-Modified-Since` 검사를 사용할 수 있다.

: 만약 엔터티 태그와 최근 변경일시가 **모두 사용가능**하다면, `HTTP/1.0`과 `HTTP/1.1` 캐시 모두 적절히 응답할 수 있도록
클라이언트는 각각을 위해 두 가지의 `재검사 정책`을 **모두 사용**해야 한다.

: HTTP/1.1 원 서버는 실현 불가능하지만 않다면 `엔터티 태그 검사기`를 보내야 하며, 이점이 있다면 강한 엔터티 태그 대신
약한 엔터티 태그를 보낼 수도 있다. 또한, `Last-Modified` 값을 같이 보내는 것도 선호된다.

: 만약 HTTP/1.1 캐시나 서버가 `If-Modified-Since`와 `엔터티 태그 조건부 헤더`를 모두 받았다면,
요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 `304 Not Modified` 응답을 반환해서는 안 된다.

## 캐시 제어
---
HTTP는 문서가 만료되기 전까지 **얼마나 오랫동안** 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을
정의한다. 우선순위대로 나열하면 다음과 같다.
    - `Cache-Control: no-store` 헤더를 응답에 첨부할 수 있다.
    - `Cache-Control: no-cache` 헤더를 응답에 첨부할 수 있다.
    - `Cache-Control: must-revalidate` 헤더를 응답에 첨부할 수 있다.
    - `Cache-Control: max-age` 헤더를 응답에 첨부할 수 있다.
    - `Expires` 날짜 헤더를 응답에 첨부할 수 있다.
    - 아무 만료 정보도 주지 않고, 캐시가 스스로 `체험적인(휴리스릭)` 방법으로 결정하게 할 수 있다.

no-cache와 no-store 응답 헤더
: HTTP/1.1은 신선도 관리를 위해 객체를 캐시하는 것을 **제한하거나** 캐시된 객체를 제공하는 여러가지 방법을 제공한다.

: `no-cache`와 `no-store` 응답 헤더는 캐시가 검증되지 않은 `캐시된 객체`로 응답하는 것을 막는다.
~~~
    Cache-Control: no-store
    Cache-Control: no-cache
    Pragma: no-cache
~~~

`no-store`가 표시된 응답은 캐시가 그 응답의 `사본`을 만드는 것을 금지한다.
캐시가 아닌 프록시 서버가 그러는 것처럼, 캐시는 클라이언트에게 `no-store` 응답을 전달하고 나면 객체를 삭제할 것이다.

`no-cache`가 표시된 응답은 사실 `로컬 캐시 저장소`에 저장될 수 있다. 다만, 먼저 서버와 `재검사`를 하지 않고서는
캐시에서 클라이언트로 제공될 수 없을 뿐이다. 이 헤더의 더 나은 이름은 `Do-Not-Serve-From-Cache-Without-Revalidation`
일 것이다.

`Pragma: no-cache` 헤더는 HTTP/1.0+와의 `하위호완성`을 위해 HTTP/1.1에 포함되어 있다.
HTTP/1.1 애플리케이션은 `Pragma: no-cache`만 이해할 수 있는 HTTP/1.0 애플리케이션에 대응해야 하는 경우가 아니면
`Cache-Control: no-cache`를 사용해야 한다.

Max-Age 응답 헤더
: `Cache-Control: max-age` 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 `흐른 시간`이고, 초로 나타낸다.
또한 `s-maxage` 헤더는 `max-age`처럼 행동하지만 `공용 캐시`에서만 적용된다.

~~~
    Cache-Control: max-age=3600
    Cache-Control: s-maxage=3600
~~~

서버는 `최대 나이먹음(maximum aging)`을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록
요청할 수 있다.

Expires 응답 헤더
: `Expires 헤더`는 `Deprecated(사용이 권장되지 않는)` 헤더이다. 초 단위의 시간 대신 `실제 만료 날짜`를 명시하며,
HTTP를 설계한 사람들은, 많은 서버가 동기화되어 있지 않거나 부정확한 시계를 갖고 있기에, 만료를 `절대시각` 대신
`경과된 시간`으로 표현하는 것이 낫다고 판단했다.

: 신선도 수명의 근사값은 만료일과 생성일의 초 단위 시간차를 계산하여 얻을 수 있다.
~~~
    Expires: Fri, 05 Jul 2002, 05:00:00 GMT
~~~

몇몇 서버는 문서를 항상 만료되도록 하기 위해 `Expires: 0` 응답 헤더를 돌려보내지만, 이는 `문법 위반`이며
문제를 일으킬 수 있다. 이런 값들을 생성해서는 안 된다.

Must-Revalidate 응답 헤더
: 캐시는 성능을 개선하기 위해 만료된 객체를 제공하도록 설정될 수 있다.
만약 캐시가 만료 정보를 엄격하게 따르길 원한다면, 원 서버는 다음과 같은 `Cache-Contol`을 붙일 수 있다

~~~
    Cache-Control: must-revalidate
~~~

`Cache-Control: must-revalidate` 응답 헤더는 캐시가 이 객체의 만료된 사본을 원 서버와의 `최초의 재검사` 없이는
제공해서는 안 됨을 의미한다.

캐시는 자유롭게 신선한 사본을 제공할 수 있다. 만약 캐시가 `must-revalidate` 신선도 검사를 시도했을 때 원 서버가
**사용할 수 없는 상태**라면, 캐시는 반드시 `504 Gateway Timeout Error`를 반환해야 한다.

휴리스릭 만료
: 만약 응답이 `Cache-Control: max-age` 헤더나 `Expires` 헤더 중 어느 것도 포함하지 않고 있다면,
캐시는 `경험적인 방법(heuristic)`으로 최대 나이를 계산할 것이다.

: 어떤 알고리즘이든 사용될 수 있지만, 계산 결과 얻은 나이 값이 `24시간`보다 크다면 `Heuristic Expiration 경고`
헤더가 응답 헤더에 추가되어야 한다. 이 경고 정보를 사용자가 볼 수 있게 해주는 브라우저는 거의 없다.

: 유명한 휴리스틱 만료 알고리즘 중 하나인 `LM 인자 알고리즘`은 문서가 `최근 변경일시`를 포함하고 있다면 사용할 수 있다.
이는 최근 변경일시를 문서가 얼마나 **자주 바뀌는지**에 대한 추정에 사용한다.

: 일반적으로 사람들은 휴리스틱 신선도 유지기간에 `상한`을 설정하여 지나치게 커지는 것을 막는다. 보통 1주일로 설정한다.

: 만약 최근 변경일조차 없다면, 캐시는 판단 근거가 될 정보를 갖지 못한 것이다.
캐시는 일반적으로 신선도에 대한 아무런 단서가 없는 문서에 대한 `기본 신선도 유지기간`(보통 한 시간이나 하루)을 설정한다.

: 더 보수적인 캐시는 이 휴리스틱 문서를 `0의 신선도 수명`을 설정하여, 캐시가 클라이언트에게 데이터를 제공할 때마다
신선도 검사를 **강제**한다.

클라이언트 신선도 제약
: `웹 브라우저`는 브라우저나 프록시 캐시의 만료된 컨텐츠를 강제로 갱신시켜주는 `리프레시`나 `리로드` 버튼을 갖고 있다.
이 버튼은 `Cache-Control` 요청 헤더가 추된 `GET` 요청을 발생시켜서, 강제로 `재검사`하거나 서버로부터 컨텐츠를 **무조건**
가져온다. 각 브라우저나 문서, 중간 캐시 설정에 따라 동작한다.

: 클라이언트는 `Cache-Control` 요청 헤더를 사용하여 `만료 제약`을 엄격하게 하거나 느슨하게 할 수 있다.
클라이언트 문서를 최신으로 유지할 필요가 있는 `애플리케이션(수동 리프레쉬 버튼과 같은)`을
위해 `Cache-Control` 헤더를 사용해 만료를 엄격하게 할 수 있다.

: 반대로 성능과 신뢰성, 비용 개선을 위해 `신선도 요구사항`을 느슨하게도 할 수 있다.
> `Cache-Contol` 요청 헤더에 `max-stale`, `only-if-cached`, `no cache` 등의 지시어를 활용할 수 있다.

주의할 점
: `문서 만료`는 완벽한 시스템이 아니다. 만약 `퍼블리셔`가 잘못하여 유효기간을 까마득한 미래로 설정한다면,
만료 전까지 그 문서에 대한 어떤 변경도 캐시에 반영되지 않을 것이다. 심지어 아예 유효기간을 사용하지 않아서,
캐시가 신선도를 알기 어렵게 되는 경우도 많다.

## 캐시 제어 설정
---
웹 서버들은 `캐시 제어`와 `만료 HTTP 헤더`들을 설정하는 서로 다른 메커니즘을 제공한다.

`Apache` 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 메커니즘을 제공한다.
`mod_headers` 모듈에 개별 헤더들을 설정하거나, `mod_expires`, `mode_cern_meta` 모듈을 사용하여 헤더를 제어한다.

HTTP-EQUIV를 통한 HTML 캐시 제어
: HTTP 서버 응답 헤더는 문서의 `만료`와 `캐시 제어 정보`를 돌려주기 위해 사용된다.
웹 서버는 제공할 `문서`에 올바른 `케시 제어 헤더`들을 부여하기 위해 `설정 파일`들과 상호작용한다.

: 웹 서버 설정 파일과 상호작용 없이도 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 하기 위해,
HTML 2.0은 `<META HTTP-EQUIV>` 태그를 정의했다. 이 태그는 HTML 문서의 최상단에 위치하여 **문서와 연동되어야** 하는
HTTP 헤더들을 정의한다.

~~~ html
    <html>
        <head>
            <title>My Document</title>
            <META HTTP-EQUIV="Cache-control" CONTENT="no-cache">
        </head>
~~~

이 태그는 원래 웹 서버에서 사용되도록 의도된 것이다. 웹 서버는 HTML에서 `<META HTTP-EQUIV>` 태그를 파싱하여 HTTP 응답에
정해진 헤더를 삽입할 것이다. `RFC 1866`에 다음과 같이 문서화 되어 있다.
> `HTTP-EQUIV` binds the element to an HTTP header field. An HTTP
server may use this information to process the document.
In particular, it may include a header field in the
responses to requests for this document: the header name
is taken from the HTTP-EQUIV attribute value, and the
header value is taken from the value of the CONTENT
attribute. HTTP header names are not case sensitive.

그러나 이 기능을 지원하는 웹 서버나 프록시는 **거의 없다.**
서버 부하를 가중시키고, 설정값은 정적, HTML 이외의 타입은 지원하지 않기 때문이다.

이로 인해 캐시 만료에 대한 동작 혼란이 초래되는 등 여러 문제가 발생할 수 있다.
따라서 대부분의 웹 서버와 프록시는 `<META HTTP-EQUIV>`를 처리하지 않는다.

## 캐시와 광고
---
광고 회사의 딜레마
: `컨텐츠 제공자`들은 아마 캐시를 좋아할 것이다. 만약 캐시가 모든 곳에 있다면 컨텐츠 제공자는 수요를 견디기 위해
`대용량 멀티프로세서 웹 서버`를 살 필요가 없을 것이며, 같은 데이터를 방문자들에게 몇 번이고 보여주기 위해 비싼 
`네트워크 서비스 요금`을 지불할 필요도 없을 것이다.
: 더욱 좋은 점은, 캐시는 `기사`나 `광고`를 사용자의 스크린에 빠르고 잘 보여줌으로써 광고 효율을 높인다는 점이다.
그러나 캐시는 원 서버가 **실제 접근 횟수**를 알 수 없게 숨길 수 있다. 만약 캐싱이 완벽하게 동작한다면,
원 서버는 HTTP 접근을 전혀 수신하지 않게 된다.

퍼블리셔의 응답
: 오늘날 광고회사들은 캐시가 광고 시청 수를 가로채지 못하도록 모든 종류의 `캐시 무력화` 기법을 사용한다.
그들은 광고를 `CGI 게이트웨이`를 통해 제공하며, 매 접근마다 광고 URL을 고쳐 쓴다.
: 그리고 이 기법은 단지 `프록시 캐시`에 대한 것이 아니다. 오늘날 모든 웹브라우저에서 켜져 있는 캐시를 주요 대상으로
하고 있다. 몇몇 컨텐츠 제공자가 그들 사이트에 대한 캐싱의 긍정적인 효과를 **감소**시키고 있는 것이다.
: 컨텐츠 제공자는 캐시가 그들의 트래픽을 **흡수하도록** 내버려 두어야 하며, 캐시는 그들에게 **얼마나 적중**했는지 알려주어야 한다.
: 오늘날에는 **모든 접근**에 대해 원 서버와 재검사하도록 캐시를 설정하여 이렇게 동작하도록 구현한다. 매 접근마다 `캐시 적중 유무`를
알리지만, 본문 데이터는 전송하지 않는다. 물론 이는 트랜잭션을 느리게 만든다.

로그 마이그레이션
: 이상적인 해결책 중 하나는 서버로 요청이 가지 않도록 하는 것이다. 결국 캐시는 모든 적중의 로그를 유지할 수 있다.
캐시는 이 로그를 서버에게 나누어 줄 수 있을 것이다.
: 그러나 `적중 로그`는 그 크기 때문에 다루기가 어렵고, 표준화도 되어있지 않다. 뿐만 아니라 인증과 프라이버시 이슈도 있다.

적중 측정과 사용량 제한
: `RFC 2227, Simple Hit-Metering and Usage-Limiting for HTTP`은 더 간단한 방법을 정의한다. 이 프로토콜은 HTTP에
특정 URL으로의 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 `Meter`라고 하는 새 헤더를 추가한다.
서버는 캐시로부터 정기적으로 `캐시된 문서`가 적중한 횟수를 받는다.
: 추가적으로 서버는 캐시가 서버에게 보고해야 하기 전까지 문서를 제공할 수 있는 `횟수`나 `처리시간`을 제어할 수 잇다.
이를 `사용량 제한`이라고 부른다. 이를 통해 캐시된 리소스의 사용량을 서버가 제한할 수 있게 된다.

## Reference
---
HTTP: The Definitive Guide