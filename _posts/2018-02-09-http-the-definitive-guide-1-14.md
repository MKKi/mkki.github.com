---
layout: post
title:  "[HTTP: The Definitive Guide] 14. 보안 HTTP"
date:   2018-02-09 16:24:16 +0900
background: '/img/posts/06.jpg'
categories: http
---

## HTTP를 안전하게 만들기
---
인터넷 뱅킹과 같은 트랜잭션을 처리하는데 있어서 `기본 인증`과 `다이제스트 인증`으로는 부족하다.
`대량 구매`, `은행 업무`, `보안 자료 접근`과 같은 중요 트랜잭션 처리를 위해 
HTTP와 `디지털 암호화 기술`을 결합해야 할 필요성이 생겼다.

HTTP의 `보안 버전`은 다음과 같은 기능들을 갖추어야 한다.
- `서버 인증` 클라이언트는 자신이 진짜 서버와 이야기하고 있음을 보장 받아야 한다.
- `클라이언트 인증` 서버는 자신이 진짜 사용자와 이야기하고 있음을 보장 받아야 한다.
- `무결성` 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- `암호화` 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- `편재성(Ubiquity)` 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- `관리의 확장성` 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- `적응성` 현재 알려진 최선의 보안 기술을 지원해야 한다.
- `사회적 생존성` 사회의 문화적/정치적 요구를 만족시켜야 한다.

#### HTTPS
`HTTPS`는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다. `넷스케이프 커뮤니케이션 주식회사`에서 개척했으며,
모든 주류 브라우저와 서버에서 지원한다.

웹 페이지에 HTTP가 아닌 HTTPS로 접근하고 있는 경우, URL이 `http://` 대신 `https://`로 시작하는 것을 보고 그 사실을
알아차릴 수 있다.

`HTTPS`를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 된다. 

HTTPS는 `HTTP 계층` 아래에 `전송 레벨 암호 보안 계층`을 제공함으로써 동작하는데, 
이 보안 계층은 `안전 소켓 계층(Secure Sockets Layer, SSL)` 혹은 그를 계승한 `전송 계층 보안(Transport Layer Security)`을 이용하여 구현된다.

![https-stack](/img/http-1-14.png)

인코딩 및 디코딩 작업은 대부분 `SSL 라이브러리` 안에서 일어나기에, `보안 HTTP`를 사용하기 위해 웹 클라이언트와
서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다.

대부분의 경우 `TCP 입력/출력 호출`을 `SSL 호출`로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만
하면 된다.

## 디지털 암호학
---
#### 비밀 코드의 기술과 과학
`암호법(crpytography)`은 메시지 인코딩과 디코딩 기술이자 과학이다. 이는 단순히 메시지를 `암호화`하는 것뿐 아니라,
메시지의 `변조`를 방지하기 위해 사용할 수도 있다.

#### 암호(cipher)
`암호`란 메시지를 인코딩하는 어떤 방법이나, 나중에 그 메시지를 디코딩하는 방법이다. 인코딩되기 전의 원본 메시지를
흔히 `평문`이라고 한다. 반대로 암호가 적용되어 코딩된 메시지를 `암호문`이라고 한다.

#### 암호 기계
암호는 상대적으로 `간단한` 알고리즘으로 시작했다. 하지만 기술이 진보하면서 사람들은 메시지를 빠르게 인코딩, 디코딩하는
기계를 만들기 시작했다.

이 `암호 기계`는 암호를 어렵게 하고자 글자를 대체하고, 순서를 바꾸었으며, 메시지를 자르고 토막내었다.

#### 키가 있는 암호
`코드 알고리즘`과 `기계`가 원치 않는 사람에게 사용될 수 있기에, 대부분의 기계들에는 암호의 `동작방식`을 변경할 수 있는
`다이얼`이 달려있다. 따라서 다이얼 없이는 디코더가 작동하지 않을 것이다.

이러한 암호 매개변수를 `키`라고 부른다. 암호 키는 암호 기계를 여러 `가상 암호 기계의 집합`처럼 만들어준다.
이 가상 암호 기계들은 **서로 다른 키 값**을 갖고 있기에 각각 다르게 동작한다.

#### 디지털 암호
디지털 계산의 도래로, `매우 큰 키`를 지원하는 것이 가능해져서,
`단일 암호 알고리즘`으로 키의 값마다 다른 `수조 개`의 가상 암호 알고리즘을 만들어 낼 수 있게 되었다.

키가 길수록 인코딩의 많은 `조합`이 가능해지고 `무작위 추출`한 키로 `크래킹`이 어려워졌다.

`기계 장치`의 물리적 금속 키나 다이얼 설정과는 달리, `디지털 키`는 그냥 숫자에 불과하다. 이는 인코딩과 디코딩
알고리즘에 대한 `입력값`이다.

`코딩 알고리즘`은 데이터 덩어리를 받아서 알고리즘과 키의 값에 근거하여 인코딩하거나 디코딩하는 `함수`이다.

## 대칭키 암호법
---
많은 디지털 암호 알고리즘은 `대칭키 암호`라 불린다. 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다.

대칭키 암호에서, `발송자`와 `수신자` 모두 통신을 위해 `비밀 키`를 똑같이 공유해야 한다.
> 대표적인 `대칭키 암호 알고리즘`으로는 `DES`, `Triple-DES`, `RC2`, `RC4` 등이 있다.

#### 키 길이와 열거 공격(Enermeration Attack)
좋은 암호 알고리즘을 `크래킹`하려면 공격자는 가능한 모든 키 값을 시도해보아야한다. 무차별로 모든 키 값을 대입해보는
공격을 `열거 공격`이라고 한다.

대칭키 암호에서는 보통 `모든 키 값`이 유효하다. 8비트라면 `256가지`, 40비트라면 `약 1조`가지가 가능하다.
> 가장 잘 알려진 비대칭 키 암호 체계인 `RSA`에서 유효한 키는 반드시 소수와 연관이 있다.

평범한 대칭키 암호에서 `40비트 키`는 작고 중요하지 않은 업무에서 충분하다고 할 수 있다.
이에 반해 `128비트 키`를 사용한 대칭키 암호는 매우 강력하다.

다음은 [암호의 종류][encrypt]에 대한 링크이다.

#### 공유키 발급하기
`대칭키 암호`의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 `공유키`를 가져야 한다는 것이다.
만약 `N명`의 사용자가 있다면, 대략 총 `N`<sup>`2`</sup>개의 비밀 키가 필요하다.

## 공개키 암호법
---
한 쌍의 호스트가 하나의 `인코딩/디코딩 키`를 사용하는 대신, `공개키 암호 방식`은 두 개의 `비대칭 키`를 사용한다.
하나는 호스트의 메시지를 `인코딩`하기 위한 것이고, 다른 하나는 그 호스트의 메시지를 `디코딩`하기 위한 것이다.

`인코딩 키`는 모두를 위해 공개되어 있다. 하지만 호스트만이 `개인 디코딩 키`를 알고 있다. 이는 누구나 메시지 인코딩을
할 수 있게 해주며, 디코딩은 제한하는 기능을 한다.

`공개키 암호화 기술`은 보안 프로토콜을 전 세계에 적용하는 것을 가능하게 했다. 
이를 위한 [공개키 인프라(Public-Key Infrastructure, PKI)][pki] 표준화 작업이 꾸준히 진행 중이다.
> `X.509`라고 불리는 이 표준은, 1988년 `X.500`으로 시작하여, 현재 최신 명세는 `RFC 5280`이다.

#### RSA
`공개키 비대칭 암호`의 과제는 `개인 키`를 계산할 수 없게 하는 것이다.

`MIT`에서 발명되고, `RSA 데이터 시큐리티`에서 상용화된 `RSA 알고리즘`은 이를 충족시키는 공개키 암호 체계이다.
이를 크랙킹 하는 것은 큰 소수를 계산하는 문제만큼 어렵다고 한다.

#### 혼성 암호 체계와 세션 키
`비대칭 공개키 암호` 방식은 보안적인 측면에서는 훌륭하지만, 알고리즘은 계산이 느린 경향이 있다.
실제로는 대칭과 비대칭 방식을 섞은 암호 방식이 쓰이곤 한다. 

예를 들어 `노드`들 사이의 안전한 `의사소통 채널`을 수립할 때는 공개키 암호를 사용하고, 이 채널을 통해 `무작위 대칭키`를 생성한다.
이후의 나머지 데이터를 암호화할 때는 `빠른 대칭키`를 사용하는 것이다.

## 디지털 서명
---
`암호 체계`는 메시지를 인코딩하고 디코딩하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 위조되지 않았음을 증명하고자
`서명`을 하도록 하는 데에 이용될 수 있다.

`디지털 서명(digital signing)`이라 불리는 이 기법은 `인터넷 보안 인증서`에게 중요하다.

#### 서명은 암호 체크섬이다
`디지털 서명`은 메시지에 붙어있는 특별한 `암호 체크섬`이며, `비대칭 공개키`에 의해 생성된다.
 이는 두 가지 이점을 갖고 있다.

- 서명은 메시지의 `저자`를 알려준다. 개인 키를 갖고 있는 사용자만이 이 체크섬을 계산할 수 있다.
즉, `체크섬`은 저자의 `개인 서명`처럼 동작한다.

- 또한, 서명은 메시지의 `위조`를 방지한다. 만약 공격자가 송신 중인 메시지를 수정했다면, 체크섬이 맞지 않게 된다.
체크섬은 `개인 키`와 관련되어 있기에, 공격자는 체크섬을 조작할 수 없다.

다음은 노드 A가 노드 B에게 메시지를 보내고, 서명하는 절차이다.

- 노드 A는 `가변 길이 메시지`를 고정된 길이의 `요약(digiest)`으로 만든다. 이에 사용자의 `개인키`를
매개변수로 하는 `서명 함수`를 적용한다. 여기서 `디코더 함수 D`가 사용된다.

- 노드 A는 계산된 `서명`과 `메시지` 모두를 노드 B에게 전송한다.

- 메시지를 받은 노드 B는 서명을 검사할 수 있다. 여기에 `공개키`를 이용한 역함수를 적용한다.
만약 `풀어낸 요약`이 노드 B가 가진 `버전`과 `요약`이 일치하지 않는다면, 위조되었거나 노드 A가 개인키를
갖고 있지 않은 것이다.

## 디지털 인증서
---
`디지털 인증서(certs)`는 신뢰할 수 있는 기관으로부터 보증 받은 `사용자`나 `회사`에 대한 정보를 담고 있다.

#### 인증서의 내부
디지털 인증서는 `인증 기관`에 의해 디지털 서명된 정보의 집합이 담겨있다.

`대상의 이름`, `유효 기간`, `인증서 발급자`, `발급자의 디지털 서명`과 같은 기본적인 것뿐 아니라, 
`공개키`와 서명 알고리즘에 대한 `서술적인 정보`도 담겨있다.

**누구나** 디지털 인증서를 만들 수 있지만, 널리 인정받는 `서명 권한`을 얻을 수 있는 것은 아니다.

#### X.509 v3 인증서
디지털 인증서에 대한 전 세계적인 `단일 표준`은 없다. 
그렇지만 오늘날 대부분의 인증서가 그들의 정보를 `X.509`라 불리는 표준화된 서식에 저장하고 있다.

`X.509 v3` 인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공한다.
다음은 `자체 서명 인증서(Self-Signed Certification)`의 예이다.

~~~
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            04:00:00:00:00:01:15:4b:5a:c3:94
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
        Validity
            Not Before: Sep  1 12:00:00 1998 GMT
            Not After : Jan 28 12:00:00 2028 GMT
        Subject: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:da:0e:e6:99:8d:ce:a3:e3:4f:8a:7e:fb:f1:8b:
                    ...
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Subject Key Identifier: 
                60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
    Signature Algorithm: sha1WithRSAEncryption
         d6:73:e7:7c:4f:76:d0:8d:bf:ec:ba:a2:be:34:c5:28:32:b5:
         ...
~~~

`X.509 기반` 인증서에는 `웹 서버 인증서`, `클라이언트 이메일 인증서`, `소프트웨어 사인코드(code-signing) 인증서`를
비롯한 몇 가지 변종이 있다.

#### 서버 인증을 위해 인증서 사용하기
사용자가 `HTTPS`를 통한 안전한 웹 트랜잭션을 시작할 때, 브라우저는 자동으로 접속한 서버에서 `디지털 인증서`를 가져온다.
만약 서버가 인증서를 갖고 있지 않다면, `보안 커넥션`은 실패한다. 

`서버 인증서`는 웹 사이트의 `이름`과 `호스트 명`, `공개키`를 포함한 많은 필드를 갖고 있다.

브라우저가 인증서를 받으면, `서명 기관`을 검사한다. 만약 기관이 신뢰할 만한 곳이면 브라우저는 `공개키`를 알고 있을 것이다.
> 브라우저는 여러 서명 기관의 인증서가 미리 설치된 채로 출하된다.

## HTTPS의 세부사항
---
`HTTPS`는 HTTP의 가장 유명한 보안 버전이다. `HTTP 프로토콜`에 대칭, 비대칭 인증서 기반 `암호 기법의 집합`을 결합한 것이다.
이는 분산된 웹 애플리케이션의 `광역 보안`과 웹 기반 `전자상거래`의 성장을 이끈 주역이다.

#### HTTPS 스킴
오늘날 `HTTPS`는 선택적이다. 따라서 웹 서버로 요청을 만들 때, HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다.
이는 `URL 스킴`을 통해 이루어진다.
> HTTPS 프로토콜에서 URL 스킴은 `https://`이다.

클라이언트는 웹 리소스에 대한 `트랜잭션 수행`을 요청받으면 URL 스킴을 검사한다.
> `http://`는 서버에 80번 포트로 연결하고 평범한 HTTP 명령을 전송한다.  
> `https://`는 서버에 433번 포트로 연결하고 서버와 `바이너리 포맷`으로 된 `SSL` 보안 매개변수를 교환하며
`핸드셰이크`를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.

`SSL 트래픽`은 바이너리 프로토콜로 HTTP와는 완전히 다르며, 기본값인 `433번 포트`로 전송된다.
만약 SSL 트래픽이 `80번 포트`로 도착한다면, 대부분의 브라우저는 잘못된 HTTP로 해석하고 커넥션을 닫을 것이다.

보안 서비스가 HTTP 쪽으로 `계층 통합`이 되도록 하면 포트가 둘 이상 필요하지 않지만, 이것이 큰 문제를 일으키진 않는다.

#### 보안 전송 셋업
`HTTP`에서 클라이언트는 웹 서버의 80번 포트로 `TCP 커넥션`을 열고, 요청과 응답을 주고 받은 후 커넥션을 닫는다.

반면 `HTTPS`에서는, 433번 포트로 커넥션이 맺어지면 클라이언트와 서버는 `암호법 매개변수`와 `교환 키`를 협상하며
SSL 계층을 초기화한다. `핸드셰이크`가 완료되면 SSL 초기화가 이루어지고, 암호화된 요청과 응답을 주고 받을 수 있게 된다.

#### SSL 핸드셰이크
`SSL 핸드셰이크`에서는 다음과 같은 일이 일어난다.

- 프로토콜 버전 번호 교환

- 양쪽이 알고 잇는 암호 선택

- 양쪽의 신원을 확인

- 채널을 암호화하기 위한 `임시 세션 키` 생성

`SSL`은 통신을 시작하기 위해 상당한 양의 `핸드셰이크 데이터`를 주고 받는다. SSL 핸드셰이크를 단순화시킨 절차는 다음과 같다.

1. 클라이언트가 `암호 후보`들을 보내고 `인증서`를 요구한다.

2. 서버는 선택한 `암호`와 `인증서`를 보낸다.

3. 클라이언트가 `비밀정보`를 보낸다. 클라이언트와 서버는 `키`를 만든다.

4. 클라이언트와 서버는 서로에게 `암호화`를 시작한다고 말해준다.

#### 서버 인증서
`SSL`은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 `상호 인증`을 지원한다.

보안 HTTPS 트랜잭션은 항상 `서버 인증서`를 요구한다. 이는 조직의 `이름`, `서버 DNS 도메인 이름` 등의 정보를 보여주는 인증서이다.
사용자는 이를 검증하여 믿을 만한 정보인지 확인할 수 있다.

#### 사이트 인증서 검사
`SSL` 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않는다.

그렇지만 대부분의 브라우저들은 인증서에 대해 `기본적인 검사`를 한 후, 더 `철저한 검사`를 할 수 있는 방법을
사용자에게 알려준다. 

`넷스케이프`가 제안한 웹 서버 인증서 검사를 위한 `알고리즘`은 대부분의 웹 브라우저의 검사 기법의 기초가 되었다.
이 알고리즘의 수행 단계는 다음과 같다.

- 먼저 브라우저는 인증서가 유효함을 확인하기 위해 인증서의 `시작 및 종료일`을 검사한다.

- 모든 인증서는 서버를 보증하는 `인증 기관(Certificate Authority, CA)`에 의해 서명되어 있다.
> CA는 `Root Certificate`라고 부르기도 한다. SSL 사용한 서비스는 CA를 통해서 인증서를 구입해야 한다.

- 한번 서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명 기관의 공개키를 서명에 적용하여
`체크섬`과 비교해봄으로써 인증서의 `무결성`을 검사한다.
> 서명이 곧 암호 체크섬이다.

- 인증서가 도용되거나 위조되는 경우를 위해 브라우저는 인증서의 `도메인 이름`을 대조해본다.
만약 다르다면, 클라이언트는 이를 사용자에게 알리거나 에러와 함께 커넥션을 종료한다.
> 보통 `단일 도메인 이름`이 들어있지만, 몇몇의 경우에는 `서버 클러스터`나 `서버 팜`을 위해 서버 이름의 목록에 대한
`와일드카드` 표현이 들어있는 인증서를 만든다.

#### 가상 호스팅과 인증서
가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
> 가상호스트란, 여러 호스트 명을 가진 하나의 서버이다.

예를 들어, `example.com`이라는 사이트가 있다고 하자. 

이 사이트의 호스팅 제공자는 공식 이름 `example.securesites.com`을 제공했다. 
하지만 사용자가 `https://www.example.com`으로 접속했을 때, 인증서 에러가 발생한다.

이유는 서버 인증서에 나열된 `공식 호스트 명(*.securesites.com)`과 `가상 호스트 명(example.com)`이 맞지 않기 때문이다.
이를 피하기 위해 사이트의 소유자는 `보안 트랜잭션`을 시작하는 모든 사용자를 `example.securesites.com`로
`리다이렉트` 해야 한다.

## 진짜 HTTPS 클라이언트
---
`SSL`은 복잡한 바이너리 프로토콜이다. 암호 전문가가 아닌 이상 가공되지 않은 `SSL 트래픽`을 직접 보내면 안 된다.

#### OpenSSL
`SSLeay` 라이브러리를 계승한 `OpenSSL`은 `SSL`과 `TLS`의 가장 인기 있는 오픈 소스이다. 
이는 강력한 다목적 암호법 라이브러리인 동시에 `SSL`과 `TLS` 프로토콜의 구현체이다.

기본적인 HTTPS 클라이언트 예시와 자세한 내용은 [OpenSSL][openssl]을 참고하라.

## 프록시를 통한 보안 트래픽 터널링
---
클라이언트는 종종 그들 대신 웹 서버에 접근해주는 `웹 프록시 서버`를 이용한다.

많은 회사가 `기업 네트워크`와 `공공 인터넷`을 잇는 경계에 보안 프록시를 설치한다.
이 프록시에서 `방화벽 라우터`가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 기타 컨텐츠 제어를 수행한다.

그러나 클라이언트가 서버로 보낼 데이터를 `서버의 공개키`로 암호화하기 시작했다면, 프록시는 더 이상 `HTTP 헤더`를 읽을 수 없다.
결국 프록시는 요청을 어디로 보내야 하는지 알 수 없게 된다.

이를 위해 `HTTPS SSL 터널링 프로토콜`을 사용한다. 클라이언트는 먼저 프록시에게 자신이 연결하고자 하는 안전한 `호스트`와
`포트`를 말해준다. 그리고 이 내용을 프록시가 읽을 수 있도록 암호화가 시작되기 전에 `평문`으로 말해준다.

HTTP는 `CONNECT` 확장 메서드를 이용하여 평문으로 된 종단 정보를 전송한다. 이는 프록시에게 희망하는 호스트와 포트로
연결해달라고 말해주며, 이후 클라이언트와 서버 사이에서 데이터가 오갈 수 있는 `터널`을 만들어준다.
> CONNECT www.example.com:443 HTTP/1.0  
> User-agent: Mozilla/1.1N 

이후 커넥션 요청에 인증이 완료되면 프록시는 목적 서버로 연결하고, 성공하면 `200 Connection Established` 응답을
클라이언트로 보낸다.
> HTTP/1.0 200 Connection established  
> Proxy-agent: Netscape-Proxy/1.1

## Reference
---
HTTP: The Definitive Guide

[encrypt]: https://namu.wiki/w/%EC%95%94%ED%98%B8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
[pki]:https://ko.wikipedia.org/wiki/X.509
[openssl]: https://www.openssl.org