---
layout: post
title:  "[HTTP: The Definitive Guide] 18. 웹 호스팅"
date:   2018-02-26 17:28:11 +0900
background: '/img/posts/04.jpg'
categories: http
---

## 호스팅 서비스
---
컨텐츠 리소스를 저장, 중개하고 관리하는 일을 통틀어 `웹 호스팅`이라 한다.

물리적인 장비 관리에서부터 고객이 직접 컨텐츠를 제공할 수 있는 총체적인 웹 호스팅까지
다양한 종류이 서비스들이 존재한다.

## 가상 호스팅
---
많은 웹 호스팅 업자는 컴퓨터 한 대를 여러 고객이 공유하게 해서 저렴한 웹 호스팅 서비스를 제공한다.
이를 `공유 호스팅` 혹은 `가상 호스팅`이라 부른다.

각 웹 사이트는 다른 서버에서 호스팅하는 것처럼 보이겠지만, 사실은 물리적으로 같은 서버에서
호스팅되는 것이다.

최종 소비자의 관점에서 가상 호스팅에 있는 웹 사이트는 물리적으로 분리된 전용 서버에서
호스팅하는 사이트와 구별할 수 없어야 한다.

가상 호스팅은 비용과 공간 그리고 관리에 이점이 있다. 가상 호스팅을 제공하는 업체는
한 서버에 수백, 수천 개의 웹 사이트를 호스팅한다.

그렇다고 PC 한 대에 수천 개의 웹 사이트를 구축하는 것은 아니다. 
[서버 팜][server-farm]이라고 불리는 복제 서버 더미를 만들고, 이에 부하를 분산할 수 있다.

팜에 있는 각 서버는 다른 서버를 복제한 것이며, 수많은 가상 웹 사이트를 호스팅하고 있기 때문에
관리자는 훨씬 편해진다.

#### 호스트 정보가 없는 가상 서버 요청
HTTP/1.0 명세는 공용 웹 서버가 호스팅하고 있는 가상 웹 사이트에 누가 접근하고 있는지
식별하는 기능을 제공하지 않는다.

HTTP/1.0 요청은 메시지의 `URL 경로 컴포넌트`만 전송한다. 

만약 `http://www.example.com/index.html`을 요청하면
브라우저는 `www.example.com`에 연결하지만, HTTP/1.0 요청은 호스트 명에 대한 별다른 언급 없이
`GET /index.html`이라는 요청을 한다.

이 경우에서 서버가 여러 개의 사이트를 가상 호스팅하고 있으면, 사용자가 어떤 가상 웹 사이트로
접속하고자 하는지 충분한 정보를 얻을 수 없다.

HTTP 리버스 프록시와 인터셉트 프록시 또한 어떤 사이트를 요청하는지에 관한 정보를 필요로 한다.

이 문제는 모든 HTTP 요청 메시지에 완전한 URL도 포함해 보내게 해서 간단히 해결했다.

HTTP/1.1을 지원하는 서버는 전체 URL을 처리할 수 있었지만, 이전 버전의 서버는 그렇지 못했다.
그 사이에 네 가지 기술이 나타났다.

#### URL 경로를 통한 가상 호스팅
공용 서버에 있는 각 가상 사이트에 서로 다른 URL 경로를 할당해서 각각을 구분할 수 있다.

예를 들어, A 사이트는 `http://www.example.com/joe/index.html`로,
B 사이트는 `http://www.new-example/mary/index.html`로 할 수 있다.

서버에 요청이 도착하면 호스트 명 정보가 요청에 포함되어 있지는 않지만, 경로에 있는 정보를 통해서
A 사이트와 B 사이트를 구분할 수 있다.

하지만 이는 좋은 해결책이 아니다. 불필요한 접두어로 URL이 혼잡스럽고, 일반적으로 홈페이지로
갈 때 사용하는 `http://www.example.com`, `http://www.example.com/index.html` 같은 URL은 동작하지 않는다.

따라서 이와 같은 URL 기반의 가상 호스팅은 거의 사용되지 않았다.

#### 포트 번호를 통한 가상 호스팅
경로 명을 변경하는 대신 A와 B 사이트에 서로 다른 포트번호를 할당할 수 있다.

하지만 이 역시 같은 문제가 있다. 사용자는 URL에 **비표준 포트**를 쓰지 않고서도 리소스를 찾기
원하기 때문이다. 

#### IP 주소를 통한 가상 호스팅
훨씬 더 좋은 방법은 `가상 IP`를 할당하는 것이다.
이 방식은 각 가상 웹 사이트에 유일한 IP 주소를 한 개 이상 부여한다.

모든 가상 서버의 IP 주소는 **같은 공용 서버**에 연결되어 있다.
서버는 HTTP 커넥션의 목적지 IP 주소를 보고 클라이언트가 어떤 웹 사이트에 연결하려고 하는지 알 수 있다.

가상 IP 호스팅은 잘 동작하지만, 규모가 큰 호스팅 업자에게는 다음과 같은 문제를 안겨준다.
- 컴퓨터 시스템에 연결할 수 있는 장비의 IP 주소 **갯수에는 제한**이 있다.

- IP 주소는 **한정적**이다. 업자는 호스팅하고자 하는 모든 웹 사이트에 할당할 충분한 가상 IP 주소를
얻지 못할 수도 있다.

- 부족한 IP 주소 문제는 서버를 **복제하면서** 더 심각해진다. 부하 균형의 구조 상, 복제된 서버에 IP 주소를
부여해야 하므로 IP 주소는 복제 서버 갯수만큼 더 필요하게 된다.

## Host 헤더를 통한 가상 호스팅
---
IP 주소의 낭비와 가상 IP의 제한 문제를 피하려면, 가상 사이트들이 같은 IP를 사용하더라도
각 사이트가 어디에 속해 있는지 알 수 있어야 한다.

이에 브라우저와 서버 개발자들은 서버가 원 호스트 명을 받아 볼 수 있게 HTTP를 확장했다.
모든 요청에 호스트 명과 포트 번호를 `Host` 확장 헤더에 기술해서 전달했다.

Host 헤더는 이와 같은 `HTTP/1.0+`에서 처음 소개되었다. `HTTP/1.1` 명세를 따르려면
Host 헤더를 반드시 기술해야 한다.

#### HTTP/1.1 Host 헤더
Host 헤더에는 원본 URL에 있는 요청 리소스에 대한 인터넷 호스트와 포트번호를 기술한다.
그리고 다음과 같은 규칙이 있다.

- Host 헤더에 포트가 기술되어 있지 않으면, 해당 스킴의 기본 포트를 사용한다.

- URL에 IP 주소가 있으면, Host 헤더는 같은 주소를 포함해야 한다.

- URL에 호스트 명이 기술되어 있으면, Host 헤더는 가튼 호스트 명을 포함해야 한다.

- URL에 호스트 명이 기술되어 있으면, Host 헤더는 호스트 명이 가리키는 IP 주소를 포함해서는 안 된다.
여러 개의 가상 사이트를 한 개의 IP 주소에 연결한 가상 호스트 서버에서 문제가 될 수 있기 때문이다.

- 클라이언트가 특정 프록시 서버를 사용한다면, Host 헤더에 프록시 서버가 아닌 원 서버의
호스트 명과 포트를 기술해야 한다.

- 웹 클라이언트는 모든 요청 메시지에 Host 헤더를 기술해야 한다.

- 웹 프록시는 요청을 전달하기 전에 요청 메시지에 Host 헤더를 추가해야 한다.

- HTTP/1.1 웹 서버는 Host 헤더 필드가 없는 HTTP/1.1 요청 메시지를 받으면
`400` 상태 코드로 응답해야 한다.

#### Host 헤더 해석하기
가상 호스팅을 지원하지 않는 원 서버는 요청 받는 호스트에 따라서 리소스가
달라지지 않기 때문에 Host 헤더 값을 무시할 것이다.

하지만 호스트를 기준으로 리소스를 구분하는 모든 웹 서버는 HTTP/1.1을 통해
오는 리소스를 결정하기 위해 다음과 같은 규칙을 적용해야 한다.

- HTTP 요청 메시지에 전체 URL이 기술되어 있으면, Host 헤더에 있는 값은 무시하고
URL을 사용한다.

- HTTP 요청 메시지에 있는 URL에 호스트 명이 기술되어 있지 않고 Host 헤더가 존재하면,
호스트 명과 포트를 Host 헤더에서 가져온다.

- 위의 단계에서 호스트를 결정할 수 없으면, 클라이언트에 `400 Bad Request` 응답을
반환한다.

## 안정적인 웹 사이트 만들기
---
#### 미러링 된 서버 팜
서버 팜은 서로 대신 할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합이다.

서버 팜의 서버에 있는 컨텐츠들은 한 곳에 문제가 생기면, 다른 한 곳에서 대신
절달할 수 있게 `미러링` 할 수 있다.

보통 미러링 된 서버는 계층적인 관계에 있다.
원본 컨텐츠를 가지고 있는 서버는 **원본 컨텐츠의 제작자**처럼 행동한다.
이 서버를 `마스터 원 서버`라고 부른다.

마스터 원 서버로부터 컨텐츠를 받은 미러링 된 서버는 `복제 원 서버`라 부른다.
서버 팜에 배포하는 간단한 방법 하나는 `네트워크 스위치`를 사용해서 서버에 `분산 요청`을 보내는 것이다.

서버에 호스팅 되고 있는 각 웹 사이트의 IP 주소는 스위치의 IP 주소가 된다.
마스터 원 서버는 복제 원 서버에 컨텐츠를 보낼 책임이 있으며,
스위치는 서버에게 요청을 전송해야 하는 책임이 있다.

미러링 된 웹 서버에는 다른 위치에 있는 컨텐츠와 정확히 같은 복제본이 있다.

마스터 원 서버는 클라이언트의 컨텐츠 요청을 받는 즉시 복제 서버로 리다이렉트 시킨다.
혹은 `DNS 리다이렉션`을 통해 DNS 서버가 클라이언트에게 전송할 IP 주소를 선택하게 할 수 있다.

#### 컨텐츠 분산 네트워크
`컨텐츠 분산 네트워크(CDN)`는 특정 컨텐츠의 분산을 목적으로 하는 단순한 네트워크이다.
네트워크의 노드는 `서버`, `대리 서버`, `프록시 서버`가 될 수 있다.

#### CDN의 대리 캐시
`대리 캐시`는 복제 원 서버를 대신해 사용될 수 있다.
`리버스 프록시`라고도 불리는 대리 서버는 미러링 된 웹 서버처럼 컨텐츠에 대한 요청을 받는다.
이들은 특정 원 서버 집합을 대신해 요청을 받는다.

대리 서버는 미러링 된 서버와는 다르게 **수요**에 따라 동작한다.
대리 서버는 원 서버의 **전체 컨텐츠**를 복사하지는 않는다. 클라이언트가 **요청하는 컨텐츠만**
저장할 뿐이다.

대리 서버의 캐시에 컨텐츠가 분산되는 방식은 요청에 따라 달라진다.
원 서버가 대리 서버의 컨텐츠를 업데이트 해줄 의무는 없다.

수요가 많은 컨텐츠를 빠르게 제공하고, 사용자가 요청하기 전에 `미리 가져오기` 기능을 가진
대리 서버도 있다. `CDN`이 대리 서버보다 캐시를 계층화하기 더 어렵다.

#### CDN의 프록시 캐시
프록시 캐시는 대리 서버와는 다르게 **어떤 웹 서버 요청이든지** 다 받을 수 있다.

하지만 대리 서버를 사용하면, 프록시 캐시의 컨텐츠 요청이 있을 때만 저장될 것이고
원본 서버 컨텐츠를 **정확히** 복제한다는 보장이 없다.

요청이 있을 때만 저장하는 프록시 캐시는 조금 다른 방식으로 동작한다.
레이어2 혹은 레이어3 장비가 중간에서 웹 트래픽을 가로채 처리하기도 한다.
> 중간 장비는 스위치나 라우터이다.

가로채기 설정은 클라이언트와 서버 사이의 모든 HTTP 요청이 물리적으로 캐시를 거치게 네트워크를
설정할 수 있는지에 따라 달라진다.

## 마치며
---
HTTP의 바이블 서적이라 불리는 `HTTP 완벽 가이드` 정리를 진행해보았습니다.

역자이신 [이응준님의 블로그 포스팅][ref-1]을 참고하여 9장, 13장, 19장, 20장, 21장은 생략했습니다.

출판된지 오래된 책이고 문체도 딱딱한 편이여서 생각보다 많은 시간이 걸렸네요.

그렇지만 HTTP 프로토콜과 웹 전반에 관한 풍부한 지식을 얻은 것 같아 만족스럽습니다.

포스팅을 진행하면서 새로운 `jekyll` 블로그도 구축해보고, `마크다운` 문법도 익힐 수 있어서
더 유익했던 시간이었습니다!

웹 전반의 큰 그림 얻고 싶으신 웹 개발자 분들께 추천드리고 싶은 책이고, 그 과정에서 제 포스팅이
도움이 되셨으면 합니다. &#128522;

## Reference
---
HTTP: The Definitive Guide

[server-farm]: https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84_%ED%8C%9C
[ref-1]: https://blog.npcode.com/2015/06/07/%EC%9B%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-http-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9D%BD%EB%8A%94-%EB%B2%95/