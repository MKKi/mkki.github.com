---
layout: post
title:  "[HTTP: The Definitive Guide] 8. 통합점: 게이트웨이, 터널, 릴레이"
date:   2018-02-05 10:56:11 +0900
background: '/img/posts/02.jpg'
categories: http
---

## 게이트웨이
---
웹에 더 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것이 분명해졌다.
이 문제에 대한 해결책으로 `인터프리터` 같이 리소스를 받기 위한 **경로를 안내**하는 역할을 하는 `게이트웨이`가 나타났다.

게이트웨이는 `리소스`와 `애플리케이션`을 연결하는 역할을 한다. 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고,
게이트웨이는 그에 응답할 수 있다. 동적인 컨텐츠를 생성하거나 데이터베이스 질의를 보낼 수도 있다.

게이트웨이는 HTTP 트래픽을 `다른 프로토콜`로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이
서버에 접속할 수 있게 하기도 한다.

클라이언트 측 게이트웨이와 서버 측 게이트웨이
: `웹 게이트웨이`는 한쪽에서는 HTTP로 통신하고, 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.
> 서로 다른 HTTP 버전 사이에서 변환을 수행하는 웹 프록시는 게이트웨이와 같다. 하지만 양쪽에서 HTTP로 통신하기에,
기술적으로는 프록시다.

게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 `빗금(/)`으로 구분해 기술한다.
> <클라이언트 프로토콜\>/<서버 프로토콜\>

- `서버 측 게이트웨이`는 클라이언트와 `HTTP`로 통신하고, 서버와는 `외래 프로토콜`로 통신한다.
- `클라이언트 측 게이트웨이`는 클라이언트와 `외래 프로토콜`로 통신하고, 서버와는 `HTTP`로 통신한다.

## 게이트웨이 프로토콜
---
프록시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 `HTTP 트래픽`을 바로 보낼 수 있다.

보통 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐 가게 하거나,
게이트웨이를 `대리 서버(리버스 프록시)`로 설정할 수도 있다.

HTTP/*: 서버 측 웹 게이트웨이
: `서버 측 웹 게이트웨이`는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을
외래 프로토콜로 전환한다.
: 이후 `객체`를 받는 대로 `HTTP 응답`에 실어서 클라이언트에 전송할 것이다.

HTTP/HTTPS: 서버 측 보안 게이트웨이
: 기업 내부의 **모든 웹 요청을 암호화**함으로써 `개인 정보 보호`와 `보안`을 제공하는데 게이트웨이를 사용할 수 있다.
클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 `세션`을 암호화할 것이다.

HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이
: `HTTPS/HTTP 게이트웨이`는 `보안 가속기`로 유명하다. 웹 서버의 앞단에 위치하고, 보이지 않는 `인터셉트 게이트웨이`나
`리버스 프록시` 역할을 한다. 이 게이트웨이는 `보안 HTTPS 트래픽`을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.
> 요즘에는 인프라 성능이 좋아져서 대부분 SSL 암/복호화 모듈을 내장한다. 로드 벨런서 중에는 SSL 모듈을 내장하여
HTTPS/HTTP 게이트웨이 역할을 해주는 것도 있다.

HTTPS/HTTP 게이트웨이는 원 서버보다 더욱 효율적으로 보안 트래픽을 복호화하는 `암호화 하드웨어`를 내장하여
원 서버의 부하를 줄여주기도 한다.

하지만 게이트웨이와 원 서버 간의 **암호화하지 않은** 트래픽을 전송하기에, 둘 사이의 안전한 네트워크가 필요로 된다.

## 리소스 게이트웨이
---
게이트웨이의 가장 일반적인 형태인 `애플리케이션 서버`는 목적지 서버와 게이트웨이를 `한 개`의 서버로 결합한다.

애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고, 서버 측에 있는 애플리케이션 프로그램에 연결하는
`서버 측 게이트웨이`이다.

애플리케이션 게이트웨이에서 유명했던 최초의 `API`는 `공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)`였다.
CGI는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하여 HTTP 응답으로 회신하는데
웹서버가 사용하는 `표준화된 인터페이스 집합`이다.

게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 `헬퍼 애플리케이션`을 생성하여 요청을 처리한다.
헬퍼 애플리케이션은 **필요한 데이터를 전달**받으며, 이 데이터는 `데이터베이스 질의` 같은 것이다. 
그리고 바로 클라이언트로 전달할 응답이나 데이터를 **서버에 반환**한다.

공용 게이트웨이 인터페이스
: `공용 게이트웨이 인터페이스(CGI)`는 `최초의 서버 확장`이자, 지금까지도 가장 널리 쓰이는 서버 확장이다.
이는 웹에서 동적인 `HTML`, `신용카드 처리`, `데이터베이스 질의` 등을 제공하는 데 사용한다.
: CGI 애플리케이션이 서버와 분리되면서 `쉘 언어`를 포함한 수많은 언어로 구현할 수 있게 되었다. 그리고 CGI는 **단순하므로**
거의 모든 HTTP 서버가 지원한다.
: CGI가 내부에서 어떤 처리를 하는지는 사용자에게 **보이지 않는다.** 사용자의 시각에서는 CGI가 내부적으로 `일반적인 요청`을
만드는 것일 뿐이다. 그리고 서버와 CGI 애플리케이션 간에 진행되는 `처리 단계`를 감춘다.
: 클라이언트가 CGI 애플리케이션이 무언가를 하고 있다는 것을 알 수 있는 유일한 단서는 URL에 있는 `CGI`, `?` 같은 것들 뿐이다.
: CGI는 거의 모든 `리소스 형식`과 `서버`의 접점에 있으면서 필요에 따라 변형이든 처리해내는 단순한 기능을 제공한다.
인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭하다고 할 수 있다.
> 해당 확장이 `서버 자체`에 들어가면, 에러가 발생하고 서버가 다운된다

서버 확장 API
: `CGI 프로토콜`은 구동 중인 HTTP 서버에 `외부 인터프리터`가 쉽게 접속할 수 있게는 해준다. 
: 개발자들은 서버 `동작`을 바꾸고 싶거나 서버의 `처리능력`을 최고치로 끌어올리고자 자신의 모듈을 HTTP와 직접 연결할 수 있는
강력한 인터페이스인 `서버 확장 API`를 제공하였다.
: 확장 API는 프로그래머가 `자신의 코드`를 서버에 **연결**하거나 서버의 `컴포넌트`를 자신이 만든 것으로 **교체**해버릴 수 있게 하였다.
: 이러한 확장은 서버 자체의 `아키텍처`에 의존하기 때문에, 대부분 **한 가지** 서버 형식으로 특화 되었다.

## 애플리케이션 인터페이스와 웹 서비스
---
애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나는 데이터를 교환하려는 두 애플리케이션 사이에서 `프로토콜 인터페이스`를
맞추는 일이다. 애플리케이션이 상호 운용을 하다보면 HTTP 헤더로는 표현하기 힘든 정보를 교환해야 할 수도 있다.

인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 `표준`과 `프로토콜 집합`을 개발하였다. 이 표준은, 원래 웹 서비스가
독립형 웹 애플리케이션 그 자체를 의미함에도, 그냥 웹 서비스로 불리게 되었다.

여기서 `웹 서비스`는 애플리케이션이 정보를 공유하는데 사용하는 새로운 메커니즘을 의미한다. 또한, HTTP 같은 `표준 웹 기술` 위에서
개발한다.

웹 서비스는 `SOAP(Simple Object Access Protocol)`을 통해 XML을 사용하여 정보를 교환한다. XML은 데이터 객체를 담는 데이터를
생성하고 해석하는 방식을 제공한다. SOAP은 HTTP 메시지에 XML 데이터를 담는 방식에 관한 표준이다.
> 오늘날 웹 서비스의 데이터 교환 방식은 `REST` 방식이 많이 사용된다. 포맷도 XML보다 `JSON`을 주로 사용된다.

## 터널
---
웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 `HTTP 애플리케이션`을 사용해 접근하는 방법을 제공한다.

웹 터널을 사용하면 `HTTP 커넥션`을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.
이를 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 `HTTP가 아닌 트래픽`을 얹기 위해서다.

따라서 웹 터널을 사용하면 **웹 트래픽만**을 허락하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다.

CONNECT로 HTTP 터널 커넥션 맺기
: 웹 터널은 HTTP의 `CONNECTION` 메서드를 사용하여 커넥션을 맺는다. CONNECT 프로토콜은 `HTTP/1.1` 명세에
자세히 나와 있지는 않지만, 많이 구현하는 `확장`이다.
> HTTP/1.1 명세에서는 CONNECT 메서드를 예약하였지만, 기능에 대한 설명은 하지 않았다

CONNECT 메서드는 `터널 게이트웨이`가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는
데이터를 **무조건** 전달하기를 요청한다. 또한, 모든 서버나 프로토콜에 TCP 커넥션을 맺는데 사용할 수 있다.

![CONNECT](/img/http-1-8-2.jpg)
> SSL 터널을 연결하기 위해 사용되는 `CONNECT`

CONNECT 요청
: CONNECT 문법은 `시작줄`을 제외하고는 다른 HTTP 메서드와 같다. **요청 URI는 호스트 명이 대신**하며 포트를 기술한다.
> CONNECT home.netscape.com:443 HTTP/1.0  
> User-agent: Mozilla/4.0

CONNECT 응답
: 클라이언트는 요청을 전송한 후 게이트웨이의 응답을 기다린다. 일반 HTTP 메시지와 같이 `200 응답 코드`는 성공을 뜻한다.
> HTTP/1.0 Connection Established  
> Proxy-agent: Netscape-Proxy/1.1

일반적인 HTTP 응답과 달리 `Content-Type` 헤더를 포함할 필요는 없다. 커넥션이 메시지를 전달하는 대신 `바이트`를 **그대로**
전달하기에, 컨텐츠의 형식을 기술하는 Content-type 헤더를 포함할 필요가 없다.

데이터 터널링, 커넥션 관리
: `터널`을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 `패킷의 순서나 흐름`에 대한 어떤 가정도
할 수 없다. 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.
> 터널의 한쪽 끝단에서 데이터를 소비하지 않으면, 반대쪽 끝단의 데이터 생산자는 `행`에 걸리게 되어 `교착상태`가 일어날 수 있다.

클라이언트는 `성능`을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 `터널 데이터`를 전송할 수 있다.

이는 서버에 데이터를 더 빨리 보내는 방법이지만, 게이트웨이가 요청에 이어서 데이터를 **적절하게** 처리할 수 있어야 함을
전제로 한다.

특히, 게이트웨이는 `네트워크 I/O 요청`이 헤더 데이터만을 반환해줄 거라고 가정할 수 없어서 커넥션이 맺어지면 헤더를
포함한 **모든** 데이터를 서버에 전송해야 한다.

요청 후에 터널을 통해 데이터를 전송한 클라이언트는 `인증요구(authentication challenge)`나 `200 외의 응답`이 왔을 때
요청 데이터를 다시 보낼 준비가 되어 있어야 한다.
> TCP 요청 패킷이 차지한 영역을 제외한 나머지 영역보다 더 큰 데이터를 파이프라인을 통해 전달하지 말아야 한다.  
> 

터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 **반대편**으로 전달된다.
그 다음, 커넥션이 `끊어졌던 터널`의 끝단 반대편의 커넥션도 프록시에 의해 끊어질 것이다. 전송하지 못한 데이터는 버려진다.

SSL 터널링
: `웹 터널`은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었다. 
터널을 사용하면 SSL 트래픽을 `HTTP 커넥션`으로 전송하여 `80 포트`의 HTTP만 허용하는 방화벽을 통과할 수 있다.

![SSL-TUNNELLING](/img/http-1-8-1.jpg)
> 터널은 `HTTP가 아닌 트래픽`을 HTTP 커넥션으로 전송한다

터널링 기능은 HTTP 메시지에 암호화된 `로우 데이터`를 담고 일반 HTTP 채널을 통해 데이터를 전송한다.

이처럼 터널은 HTTP가 아닌 트래픽이 `포트`를 제한하는 방화벽을 통과할 수 있게 해준다.
이는 보안 SSL 트래픽이 방화벽을 통과하도록 활용할 수 있지만, `악의적인 트래픽`이 유입되는 경로가 될 수도 있다.

SSL 터널링 vs HTTP/HTTPS 게이트웨이
: `HTTPS 프로토콜`은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할 수 있다.
: 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 `HTTPS 트랜잭션`을 수행하는 방식이다.
응답은 프록시가 받아서 `복호화`하고 난 후에, HTTP를 통해 클라이언트로 전송한다.
: 이 접근은 몇 가지 단점이 있다.
    - `클라이언트`-`게이트웨이` 사이에는 보안이 적용되지 않은 `일반 HTTP 커넥션`이 맺어진다.
    - 프록시가 인증을 담당하고 있기에, 클라이언트는 원격 서버에 `SSL 클라이언트 인증(X509 인증서 기반)`을 할 수 없다.
    - 게이트웨이는 `SSL`을 완벽히 지원해야 한다.

이 상황에서 `SSL 터널링`을 사용하면, 프록시에 SSL을 **구현할 필요가 없다.**
`SSL 세션`은 클라이언트가 생성한 요청과 목적지 웹 서버 간에 생선된다.

프록시 서버는 `트랜잭션`의 보안에는 관여하지 않고 암호화된 데이터를 그대로 `터널링`할 뿐이다.

터널 인증
: 터널에서 프록시 인증 기능은 클라이언트가 터널을 사용할 수 있는 `권한`을 검사하는 용도로 사용할 수 있다.

터널 보안에 대한 고려사항
: `터널 게이트웨이`는 통신하고 있는 `프로토콜`이 터널을 올바르게 사용하고 있는지 검증할 방법이 없다.
터널의 오용을 최소화하기 위해서, 게이트웨이는 HTTPS 전용 포트인 `443`과 같은 특정 포트만 커널링할 수 있게
허용해야 한다.

## 릴레이
---
HTTP 릴레이는 `HTTP 명세`를 완전히 준수하지 않는 간단한 `HTTP 프록시`다.
릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 `맹목적`으로 전달한다.

HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 **수행하지 않고** 맹목적으로 트래픽을 전달하는 `간단한 프록시`를
구현하는 방식이 유용할 때가 있다. 

이는 단순 필터링이나 진단, 컨텐츠 변환을 하는데 사용되기도 한다.
하지만 잠재적으로 심각한 `상호 운용 문제`를 가지고 있기 때문에 주의해서 배포해야 한다.

`단순 맹목적 릴레이`를 구현하는데 관련된 더 일반적인 문제 중 하나는 맹목적 릴레이가 `Connection 헤더`를 제대로
처리하지 못해서 `keep-alive 커넥션`이 `행(hang)`에 걸리는 것이다.
> `Connection 헤더`는 홉과 홉 사이에만 사용하는 헤더인데, 이를 이해하지 못하고 다음 홉에 넘겨 `행`이 걸리는 것이다.

이러한 위험을 예방하고자 `릴레이`를 조금이나마 **똑똑하게** 만드는 방법이 있지만,
`프록시`의 단순함 이면에는 상호 운용과 관련된 문제가 발생할 위험이 있다.